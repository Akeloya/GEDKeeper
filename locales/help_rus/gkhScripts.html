<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<title>Справка GEDKeeper. Использование скриптов</title>
<link rel="stylesheet" href="styles.css" type="text/css" />
</head>

<body>

<h1>Оглавление</h1>
<ul>
	<li><a href="#1">1 - Введение в Lua</a>
	<li><a href="#2">2 – Описание языка Lua</a>
	<li><a href="#3">3 - Использование Lua в программе GEDKeeper</a>
</ul>

<h1><a name="1">1 - Введение в Lua</a></h1>

<p>Lua является типичным процедурным языком программирования, предоставляющим широкие возможности для разработки.
Это мощный и простой язык, обладающий всеми необходимыми выразительными средствами.</p>

<p>Будучи языком для создания расширений, Lua не имеет понятия основной программы,
он работает в среде исполнения других программ, сокращенно называемых <b>хост-программами</b>.
В данном случае хост-программой является программа GEDKeeper. Хост-программа позволяет
запускать части кода (далее скрипты), написанные на Lua. Благодаря возможности расширения функциями хост-программы, Lua может
применяться для решения широкого круга задач.</p>

<p>Lua является свободно распространяемым программным средством, поэтому предоставляется без каких-либо гарантий в соответствии с лицензией.
Версия <b>lua 5.1</b>, которая описана в данном Руководстве, доступна на официальном сайте Lua <b>www.lua.org</b>.</p>

<p>Как и многие подобные Руководства, этот документ написан в формальном стиле. Для получения более подробной информации об особенностях применения языка
рекомендуем обратиться к технической документации, доступной на официальном сайте Lua. Хорошим подспорьем в работе может оказаться книга Роберта Иерусалимского (Roberto Ierusalimschy)
«Программирование на Lua», второе издание <em>(Programming in Lua (Second Edition))</em>.</p>

<h1><a name="2">2 – Описание языка Lua</a></h1>

<p>В этой главе описываются элементы языка, способы их комбинирования и значение языковых конструкций.</p>

<p>Конструкции языка будут вводится с использованием расширенной BNF, где запись {<em>a</em>} означает 0 или более элементов <em>a</em>,
а запись [<em>a</em>] означает его необязательное вхождение. Нетерминальные символы отображаются обычным шрифтом, ключевые слова
выделяются жирным шрифтом <b>kword</b>, все остальные терминальные символы заключаются в апострофы `<b>=</b>?.</p>


<h2><a name="2.1">2.1 – Лексические соглашения</a></h2>

<p><em>Именами</em> (<i>идентификаторами</i>) в Lua могут быть любые строки из букв, цифр и символа подчеркивания, не начинающиеся с
цифры. Это правило типично для большинства языков программирования. Идентификаторы используются для именования переменных и таблиц значений.</p>

<p>Следующие <i>ключевые слова </i>зарезервированы и не могут быть использованы в именах:</p>

<div class="contdiv"><pre><code class="lua">
and      break    do	 else       elseif
end      false    for    function   if
in       local    nill   not        or
repeat   return   then   true       until   while
</code></pre></div>

<p>Lua является языком, чувствительным к регистру символов: and – ключевое слово, тогда как And и AND – два разных допустимых идентификатора. По соглашению, имена,
начинающиеся с символа подчеркивания и записанные в верхнем регистре (например, _VERSION), зарезервированы для использования в качестве внутренних глобальных переменных,
используемых Lua.</p>

<p>В следующих строках показаны другие допустимые символы:</p>

<div class="contdiv"><pre><code class="lua">
+   *   /   %   ^   <   #
==   ~=   &lt;=   &gt;=   &lt;   &gt;   =
(   )   {   }   [   ]>
;   :   ,   .    ..   ...
</code></pre></div>

<p><em>Литеральные строки </em><em>должны быть заключены в одинарные или двойные кавычки и</em> могут
содержать следующие С-подобные escape-последовательности:
'\a' («звонок»), '\b' («забой»), '\f' («перевод страницы»),
'\n' («перевод на новую строку»), '\r' («возврат каретки»),
'\t' («горизонтальная табуляция»), '\v' («вертикальная табуляция»),
'\\\&quot;' («двойная кавычка»), and'\'' (апостроф [«одинарная кавычка»]). Кроме
того, обратный слеш ставится перед концом строки в редакторе, когда для
удобства набора длинные непрерывные строки записываются в несколько строк. Символ
в строке также может быть представлен своим кодом с помощью escape-последовательности \<em>ddd</em>, где <em>ddd</em>-
последовательность из не более чем трех цифр. (Заметим, что если после символа,
записанного с помощью своего кода, должна идти цифра, то код символа в escape-последовательности
должен содержать ровно три цифры). Строки в Lua могут содержать любые 8-битные
значения, включая ноль, который записывается как '\0'.</p>

<p>Чтобы поместить одни двойные кавычки, символы новой строки, обратный слэш, или нулевой символ в строку, ограниченную двойными кавычками вы
должны использовать escape-последовательности. Любой другой символ может быть напрямую включен в строку.</p>

<p>Символьные строки могут также определяться используя длинный формат, ограниченный <em>длинными скобками</em>.
Мы определяем <em>открывающую длинную скобку уровня n</em> как открывающую квадратную скобку следующую за <em>n</em>
знаками равенства следующими за другой открывающей квадратной скобкой. Так, открывающая длинная скобка уровня &nbsp;0
записывается как [[, открывающая длинная скобка уровня &nbsp;1 записывается как [=[, и так далее.
<em>Закрывающая длинная скобка</em> определяется также; для примера, закрывающая скобка уровня &nbsp;4
записывается как ]====]. Длинные строки начинаются с
открывающей длинной скобки любого уровня и заканчиваются первой закрывающей длинной скобкой
соответствующего уровня. Литералы в такой форме могут находится в разных строках, escape-последовательности
не интерпретируются, и игнорируются длинные скобки любого другого уровня.
Они могут содержать что угодно, исключая закрывающую скобку соответствующего уровня.</p>

<p>Для удобства, когда открывающая длинная скобка следует непосредственно в новой линии,
эта линия не включается в строку. Для примера, в системе использующей ASCII (в которой 'a' кодируется как&nbsp;97,
новая строка как&nbsp;10, и '1' как&nbsp;49), пять литералов ниже обозначают одну строку:</p>

<div class="contdiv">
<pre>     a <span class="S10">= '</span> alo<span class="S10">\</span>n123&quot;<span class="S10">'</span></pre><pre>     a <span class="S10">=</span> &quot;alo<span class="S10">\</span>n123<span class="S10">\</span>&quot;&quot;</pre><pre>     a <span class="S10">=</span> '<span class="S10">\</span>97lo<span class="S10">\</span>10<span class="S10">\</span>04923&quot;'</pre><pre>     a <span class="S10">= [[</span>alo</pre><pre>     123&quot;<span class="S10">]]</span></pre><pre>     a <span class="S10">= [==[</span></pre><pre>     alo</span></pre><pre>     123&quot;<span class="S10">]==]</span></pre>
</div>

<p><em>Числовая константа</em> может быть записана с опциональной десятичной частью
и опциональной десятичной экспонентой. Lua также принимает целый шестнадцатеричные константы, с префиксом 0x.
Примеры правильных числовых констант </p>

<pre><o:p>&nbsp;</o:p></pre><pre>     3   3.0   3.1416   314.16e-2   0.31416E1   0xff   0x56</pre>

<p><em>Комментарий</em> начинается с двойного дефиса (--) везде за пределами строки. Если текст непосредственно после -- не содержит длинную открывающую скобку [,
комментарий является <em>коротким</em>, который продолжается до конца строки. Иначе, это <em>длинный комментарий</em>, который продолжается пока не встретится
закрывающая длинная скобка ]. Длинный комментарий часто встречается для временной деактивации кода.</p>


<h2><a name="2.2">2.2 – Значения и типы</a></h2>

<p>Lua представляет собой язык с <i>динамическим определением типов данных</i>. Переменная языка может содержать значения любого типа.
Возможности определения пользовательских типов данных отсутствуют. Все значения в Lua могут храниться в переменных, использоваться в качестве аргументов при вызове функций
и возвращаться в виде результата их выполнения.</p>

<p>В Lua восемь основных типов: <em>nil (неопределенный)</em>, <em>boolean (логический)</em>,
<em>number (числовой)</em>, <em>string (строковый)</em>, <em>function (функция)</em>,
<em>userdata (пользовательские данные)</em>, <em>thread (поток)</em>, и <em>table (таблица)</em>.

<em>Nil - </em>это тип значения <b>nil [пустое значение]</b>, главное свойство
которого – отличаться от всех остальных значений и обозначать отсутствие
пригодного значения. К типу <em>Boolean</em> относятся значения <b>false</b> (ложь) и <b>true </b>(истина). Значения <b>nil</b> и
<b>false</b> считаются ложными, любое другое значение считается истинным.
К типу <em>Number</em> относятся вещественные числа (двойной точности с плавающей запятой).
Тип <em>String </em><em>обозначает</em> массивы символов. Строки Lua могут содержать
любые 8 битные символы, включая ноль ('\0') (см. <a href="#2.1">§2.1</a>).</p>

<p>В Lua можно использовать функции, написанные на Lua или предоставляемые хост-программой (см. <a href="#2.5.8">§2.5.8</a>).</p>

<p>Тип <em>userdata (пользовательские данные) </em> позволяет хранить любые данных из хост-программы в переменных Lua. Значение этого типа является
ссылкой на блок физической памяти и не имеет предопределенных операций в Lua, за исключением
присваивания и проверки на равенство. Однако, используя <em>метатаблицы</em>, программист
может определить операции над значениями этого типа (см. <a href="#2.8">§2.8</a>).
Значения типа userdata не могут быть созданы или изменены непосредственно в Lua, это возможно только
с помощью хост-программе. Такой подход гарантирует целостность данных, принадлежащих ведущей программе.</p>

<p>Тип <em>table (таблица)</em> определяет ассоциативные массивы. Такие массивы могут индексироваться не только числами, но и любыми значениями (за
исключением <b>nil</b>). Таблица может содержать значения сразу нескольких типов (кроме <b>nil</b>). Таблицы представляют собой единственный механизм
структурирования данных в Lua;  они могут использоваться как простые массивы, таблицы символов, множества, поля записей, деревья и так далее. Для представления словарей Lua использует
имя поля в качестве индекса таблицы. Представление в виде a.name считается тождественным представлению a[&quot;name&quot;]. В Lua есть несколько
способов создания таблиц (см. <a href="#2.5.7">§2.5.7</a>).</p>

<p>Индексы и значения полей таблицы могут быть любого типа (кроме <b>nil</b>). В частности, так как функции являются значениями встроенного типа, поля таблицы могут содержать и
функции. Таким образом, таблицы могут хранить методы <em>methods</em> (см. <a href="#2.5.9">§2.5.9</a>).</p>

<p>Переменные типа <i>table</i>, <i>function</i>, <i>thread</i> и <i>userdata</i> не
содержат самих данных, в них хранятся только ссылки на соответствующий объект. Присваивание,
передача параметров и возврат результата из функции оперируют только ссылками
на значения, эти операции никогда не ведут к созданию копий.</p>

<p>Библиотечная функция <i>type</i> возвращает строку, описывающую тип данного значения.</p>


<h3><a name="2.2.1">2.2.1 – Приведение типов</a></h3>

<p>Lua обеспечивает автоматическое преобразование между строковыми и числовыми значениями в процессе выполнения. Любая арифметическая операция, применяемая к строке, пытается
преобразовать эту строку в соответствующее число по обычным правилам приведения. Когда же число используется там, где ожидается строка, это число преобразуется в
строку в произвольном подходящем формате. Так что для получения какого-то конкретного представления числа в строке необходимо использовать функцию
<span style='font-size:10.0pt;'>format</span> из библиотеки работы со строками (см. <a href="#pdf-string.format">
<span  style='font-size:10.0pt;'> string</span><span style='font-size:10.0pt'>.</span><span lang="en-us" style='font-size:10.0pt;'>format</span></a>).</p>


<h2><a name="2.3">2.3 - Переменные</a></h2>

<p>Переменные используются для хранения значений в процессе выполнения программы. В Lua есть три вида переменных: глобальные, локальные и поля таблиц.</p>

<p>Отдельный идентификатор может обозначать глобальную или локальную переменную (либо формальный параметр функции, что является частным случаем локальной переменной) :</p>

<div class="contdiv"><pre><code class="lua">
var ::= Name Имя
</code></pre></div>

<p>Где Name – идентификатор, определяемый в соответствии с <a href="#2.1">§2.1</a>.</p>

<p>Любая переменная считается глобальной, если она явно не объявлена как локальная (см. <a href="#2.4.7">§2.4.7</a>). Локальные переменные
существуют в лексическом контексте: локальные переменные доступны функциям, определенным внутри этого контекста (см. <a href="#2.6">§2.6</a>).</p>

<p>До первого явного присвоения значением переменной является <b>nil</b>.</p>

<p>Квадратные скобки используются для доступа к элементу таблицы по индексу:</p>

<div class="contdiv"><pre><code class="lua">
var ::= prefixexp '[' exp ']'
</code></pre></div>

<p>Способ доступа к глобальным переменным и полям таблицы может быть изменен с помощью мететаблиц. Доступ к переменной t[i] эквивалентен вызову gettable_event(t,i).
(Полное описание функции gettable_event смотрите в <a href="#2.8">§2.8</a>. Эта функция недоступна в коде Lua, мы упомянули ее здесь в качестве примера).</p>

<p>Запись var.Name аналогична записи var[&quot;Name&quot;]:</p>

<div class="contdiv"><pre><code class="lua">
var ::= prefixexp '.' Name
</code></pre></div>

<p>Все глобальные переменные являются полями в обычных таблицах Lua, называемых таблицами окружения или кратко окружениями (см. <a href="#2.9">§2.9</a>). Каждая функция имеет ссылку
на свое собственное окружение, и все глобальные переменные внутри этой функции ссылаются на данную таблиц. В момент создания функция наследует окружение вызывающей функции. Для получения
таблицы окружения функции Lua можно вызвать функцию <a href="#pdf-getfenv">getfenv</a>. Для перезаписи таблицы используется <a href="#pdf-setfenv">setfenv</a>.
(Вы можете манипулировать окружением C&nbsp;функций только с помощью отладочной библиотеки (см. <a href="#5.9">§5.9</a>).) </p>

<p>Обращение к глобальной переменной x эквивалентно _env.x, а также </p>

<div class="contdiv"><pre><code class="lua">
gettable_event(_env, "x")
</code></pre></div>

<p>где _env – окружение выполняющейся функции. (Полное описание функции gettable_event смотрите в <a href="#2.8">§2.8</a>.
Эта функция недоступна в коде Lua, мы упомянули ее здесь в качестве примера).</p>


<h2><a name="2.4">2.4 – Операторы</a></h2>

<p>В Lua поддерживается стандартный набор операторов, почти как в Pascal или C. Он состоит из операторов присваивания, операторов управления потоком исполнения,
вызова функций и описания переменных.</p>


<h3><a name="2.4.1">2.4.1 – Порции</a></h3>

<p>Единица исполнения Lua называется <em>chunk (порция)</em>. Порция – это любая последовательность операторов Lua. Операторы в порции могут разделяться запятыми:</p>

<div class="contdiv"><pre><code class="lua">
chunk ::= {stat [';']}
</code></pre></div>

<p>Пустого оператора в языке нет, поэтому выражение ';;' не допустимо.</p>

<p>Lua воспринимает порцию как неименованную функцию с произвольным набором параметров (см. <a href="#2.5.9">§2.5.9</a>). Порция может определять локальные
переменные и возвращать значения.</p>

<p>Порция может храниться в файле или в строке базовой программы. В момент запуска порции на выполнение осуществляется компиляция ее в промежуточный
байт-код (инструкции для виртуальной машины). Затем полученный код исполняется виртуальной машиной.</p>


<h3><a name="2.4.2">2.4.2 – Блоки</a></h3>

<p>Блок это список операторов; синтаксически блок тождественно равен порции (chunk) :</p>

<div class="contdiv"><pre><code class="lua">
block ::= chunk
</code></pre></div>

<p>Блок операторов может быть явно ограничен, таким образом представляется составной оператор:</p>

<div class="contdiv"><pre><code class="lua">
stat ::= do block end
</code></pre></div>

<p>С помощью составных операторов можно ограничивать области видимости локальных переменных. Также составные операторы используются в циклах и условном
операторе (см. <a href="#2.4.4">§2.4.4</a>).</p>


<h3><a name="2.4.3">2.4.3 – Присваивание</a></h3>

<p>Lua поддерживает параллельное присваивание. В общем случае, оператор присваивания выглядит как список переменных, символ ‘=’ и список выражений.
Элементы списков указываются через запятую:</p>

<div class="contdiv"><pre><code class="lua">
	stat ::= varlist1 '=' explist1

	varlist1 ::= var {',' var}

	explist1 ::= exp {',' exp}
</code></pre></div>

<p>Выражения (exp) рассмотрены в <a href="#2.5">§2.5</a>.</p>

<p>Перед выполнением присваивания список переменных согласовывается по длине со списком выражений. Если список справа длиннее, то его лишние элементы просто отбрасываются.
Если короче, то недостающие позиции дополняются значениями <b>nil</b>. Если список операторов оканчивается вызовом функции, то перед согласованием все возвращаемые оттуда
значения вставляются в правый список (за исключением случаев, когда вызов взят в скобки; смотрите <a href="#2.5">§2.5</a>).</p>

<p>Перед выполнением присваивания вычисляется значение всех выражений. Код</p>

<div class="contdiv"><pre><code class="lua">
	i = 3

	i, a[i] = i+1, 20
</code></pre></div>

<p>означает, что переменной a[3] присваивается значение 20, потому что i в выражении a[i] имеет то же самое значение, что и в момент вычисления выражения i+1.
Аналогично, строка</p>

<div class="contdiv"><pre><code class="lua">
	x, y = y, x
</code></pre></div>

<p>является простым способом обмена значениями двух переменных (при «традиционном» способе требуется дополнительная переменная).</p>

<p>Действие операции присваивания для глобальных переменных и полей таблиц может быть переопределено посредством метатаблиц.
Присваивание индексной переменной t<span class="S10">[</span>i<span class="S10">]</span> <span class="S10">=</span> val
эквивалентно вызову settable_event<span class="S10">(</span>t<span class="S10">,</span>i<span class="S10">,</span>val<span class="S10">)</span>.
(Полное описание функции settable_event смотрите в <a href="#2.8">§2.8</a>. Эта функция недоступна в коде Lua, мы упомянули ее здесь в качестве примера).</p>

<p>Присваивание к глобальной переменной x<span class="S10">=</span>val эквивалентно присваиванию _env.x=val, то же самое произойдет при вызове</p>

<div class="contdiv"><pre><code class="lua">
	settable_event(_env, "x", val)
</code></pre></div>

<p>где _env окружение запущенной функции. (Переменная _env недоступна в Lua, мы приводим ее здесь в качестве примера. ) </p>


<h3><a name="2.4.4">2.4.4 – Управляющие конструкции</a></h3>

<p>Операторы <b>if</b>, <b>while</b>, и <b>repeat</b> имеют обычное значение и знакомый синтаксис:</p>

<div class="contdiv"><pre><code class="lua">
	stat ::= while exp do block end

	stat ::= repeat block until exp

	stat ::= if exp then block {elseif exp then block} [else block] end
</code></pre></div>

<p>В Lua также имеется выражение <b> for </b>в двух вариантах (см. <a href="#2.4.5">§2.4.5</a>).</p>

<p>Логическое выражение в управляющих конструкциях может возвращать любое значение.
Значения <b>false</b> и <b>nil</b> считаются ложными. Все остальные значения считаются
истинными (в том числе значение 0 и пустая строка!).</p>

<p>Цикл <b>repeat</b>–<b>until</b> оканчивается условием, идущим следом за <b>until</b>, поэтому
в условии можно ссылаться на локальные переменные, описанные внутри цикла.</p>

<p>Выражение <b>return</b> используется для того, чтобы возвратить значения из функции или
порции. Синтаксис оператора <b>return</b> позволяет функции или порции вернуть несколько значений:</p>

<div class="contdiv"><pre><code class="lua">
	stat ::= return [explist1]
</code></pre></div>

<p>Оператор <b>break</b> используется для досрочного выхода из циклов <b>while</b>, <b>repeat</b> и <b>for</b>:</p>

<div class="contdiv"><pre><code class="lua">
	stat ::= break
</code></pre></div>

<p><b>Break</b> прерывает цикл, в теле которого встречается, внешние циклы продолжают выполнение.</p>

<p><b>Return</b> (или <b>break)</b> должен быть <i>последним</i> оператором в блоке (иначе следующие за ним операторы никогда не выполнятся). Если действительно
необходимо вставить <b>return</b> или <b>break</b> в середину блока, то следует применить составной оператор, например, do return end и do break end.</p>


<h3><a name="2.4.5">2.4.5 – Оператор For</a></h3>

<p>Оператор <b>for</b> допускает простую и расширенную формы записи.</p>

<p>В простой форме <b>for</b> выполняет блок кода до тех пор, пока переменная цикла, изменяеющаяся в арифметической прогрессии, не достигнет установленного порога.</p>

<div class="contdiv"><pre><code class="lua">
	stat ::= for Name ' = ' exp1 ',' exp2 [', ' exp3] do block end
</code></pre></div>

<p><em>block</em> повторяется для переменной цикла <em>name</em> начиная со значения выражения <em>exp1</em>, до тех пор пока выполняется выражение <em>exp2</em> с
шагом выражения <em>exp3</em>.</p>

<p>Таким образом, запись </p>

<div class="contdiv"><pre><code class="lua">
	for v = e1, e2, e3 do block end
</code></pre></div>

<p>эквивалентна коду</p>

<div class="contdiv"><pre><code class="lua">
	do
		local var, limit, step = tonumber(e1), tonumber(e2), tonumber(e3)

		if not (var and limit and step) then error() end

		while (step > 0 and var <= limit) or (step <= 0 and var >= limit) do

			local v = var

			block

			var = var + step
		end
    end
</code></pre></div>

<p>Обратите внимание, что:</p>

<ul type=disc class="contul">
 <li>Все три логических выражения вычисляются только один раз перед началом цикла, причем полученные значения должны быть числами.</li>

 <li><em>var</em>, <em>limit</em>, и <em>step</em> - неявные переменные, мы условно именовали их здесь для объяснения логики работы </li>

 <li>Если выражение step (шаг) отсутствует, то по умолчанию используется 1 </li>

 <li>Для выхода из цикла <b>for</b> используйте <b>break</b>.</li>

 <li>Переменная <b>v</b> является локальной для цикла; вы не сможете использовать ее значение после выхода
     из цикла <b>for</b>. Если вам необходимо значение этой переменной, присвойте его другой переменной перед выходом из цикла.</li>
</ul>

<p>Расширенная форма оператора <b>for</b> реализована с использованием функций
<i>итераторов</i>. На каждом обороте для получения нового значения переменной цикла вызывается <i>итератор</i>.
Цикл заканчивается, когда <i>итератор </i>вернет <b>nil</b>. Синтаксис расширенного оператора <b>for</b>:</p>

<div class="contdiv"><pre><code class="lua">
	stat ::= for namelist in explist1 do block end

	namelist ::= Name {', '~ Name}
</code></pre></div>

<p>Запись</p>

<div class="contdiv"><pre><code class="lua">
	for var_1, ···, var_n in explist do block end
</code></pre></div>

<p>можно представить как</p>

<div class="contdiv"><pre><code class="lua">
	do
		local f, s, var = explist

		while true do
			local var_1, ···, var_n = f(s, var)

			var = var_1

			if var == nil then break end

			block
		end
    end
</code></pre></div>

<p>Заметим, что</p>

<ul type=disc class="contul">
 <li><em>explist</em> вычисляется только однажды. Его результатом является функция-<i>итератор, </i>таблица состояний и начальное значение индекса </li>

 <li><em>f</em>, <em>s</em>, и <em>var</em> неявные переменные, именованные здесь для примера </li>

 <li>Выйти из цикла можно с помощью оператора <b>break</b>.</li>

 <li>Переменная <em>var</em><em>_</em><em>i</em> является локальной; вы не сможете использовать ее значение после выхода из <b>for</b>. Если вам необходимо ее
     значение, заранее сохраните его в другой переменной.</li>
</ul>


<h3><a name="2.4.6">2.4.6 – Вызов функции</a></h3>

<p>Для создания побочных эффектов может быть полезен вызов функций, используемый в качестве оператора:</p>

<div class="contdiv"><pre><code class="lua">
	stat ::= functioncall
</code></pre></div>

<p>В этом случе все возвращаемые значения отбрасываются. Вызовы функций рассматриваются в <a href="#2.5.8">§2.5.8</a>.</p>


<h3><a name="2.4.7">2.4.7 – Локальные объявления</a></h3>

<p>Локальные переменные могут быть объявлены где угодно внутри блока. Объявление может включать инициализацию:</p>

<div class="contdiv"><pre><code class="lua">
	stat ::= local namelist ['=' explist1]
</code></pre></div>

<p>Инициализация обладает всеми свойствами операции присваивания (в том числе параллельностью) (см. <a href="#2.4.3">§2.4.3</a>). По умолчанию все переменные
инициализируются значением <b>nil</b>.</p>

<p>Порция является блоком (см. <a href="#2.4.1">§2.4.1</a>), поэтому локальные переменные могут быть объявлены вне любого явно заданного блока. Областью действия
таких локальных переменных являются границы порции.</p>

<p>Правила видимости для локальных переменных рассмотрены в <a href="#2.6">§2.6</a>.</p>


<h2><a name="2.5">2.5 - Выражения</a></h2>

<p>Выражениями в Lua являются следующие конструкции:</p>

<div class="contdiv"><pre><code class="lua">
	exp ::= prefixexp

	exp ::= nil | false | true

	exp ::= Number

	exp ::= String

	exp ::= function

	exp ::= tableconstructor

	exp ::= '...'

	exp ::= exp binop exp

	exp ::= unop exp

	prefixexp ::= var | functioncall | '(' exp ')'
</code></pre></div>

<p>Числа и символьные строки рассмотрены в <a href="#2.1">§2.1</a>; переменные - в <a href="#2.3">§2.3</a>; описания функций - в <a href="#2.5.9">§2.5.9</a>; вызовы
функций - в <a href="#2.5.8">§2.5.8</a>; конструкторы таблиц - в <a href="#2.5.7">§2.5.7</a>. Неявные аргументы, обозначаемые ‘...', могут использоваться только внутри
соответственно заданной функции; смотрите <a href="#2.5.9">§2.5.9</a>.</p>

<p>К бинарным операциям (binop в формальном определении выражения) относятся арифметические (см. <a href="#2.5.1">§2.5.1</a>), операции сравнения (<a href="#2.5.2">§2.5.2</a>),
булевские (<a href="#2.5.3">§2.5.3</a>) и операции конкатенации (смотреть <a href="#2.5.4">§2.5.4</a>). Унарными являются унарный минус (<a href="#2.5.1">§2.5.1</a>),
отрицание <b>not</b> (<a href="#2.5.3">§2.5.3</a>) и операция получения длины <b>#</b> (<a href="#2.5.5">§2.5.5</a>).</p>

<p>Результат вызова функций и неявные параметры могут содержать несколько значений. Если при этом они используются в качестве оператора (<a href="#2.4.6">§2.4.6</a>)
(только для функций), то все возвращаемые значения отбрасываются. Если это последний (или единственный) элемент в списке выражений, то никакая корректировка не проводится (если вызов не взят
в скобки). В остальных случаях Lua приводит возвращаемый список к одному элементу, отбрасывая все значения кроме первого.</p>

<p>Далее несколько примеров:</p>

<div class="contdiv"><pre><code class="lua">
	f()                -- результат функции отбрасывается

	g(f(), x)          -- берется первое значение из списка - результата вызова f()

	g(x, f())          -- g получает x и все значения, полученные из f()

	a,b,c = f(), x     -- берется первый элемент результата вызова f()(и c получает nil)

	a,b = ...          -- a получает первый параметр из ..., b - второй (причем а и b могут получить nil, если в качестве неявных параметров ничего не передано)

	a,b,c = x, f()     -- 2 результата из f()

	a,b,c = f()        -- 3 результата из f()

	return f()         -- возвращает все значения из f()

	return ...         -- возвращает все полученные неявные аргументы

	return x,y,f()     -- вернет a, b и все, что вернет f()

	{f()}              -- создаст список со всем результатами вызова f()

	{...}              -- создаст список со всеми неявными параметрами

	{f(), nil}         -- 1 результат из f()
</code></pre></div>

<p>Выражение, заключенное в скобки, всегда возвращает только одно значение. Таким образом,
<span class="S10">(</span>f<span class="S10">(</span>x<span class="S10">,</span>y<span class="S10">,</span>z<span class="S10">))</span>
всегда даст единственное значение, даже если f возвращает несколько.
(Значение <span class="S10">(</span>f<span class="S10">(</span>x<span class="S10">,</span>y<span class="S10">,</span>z<span class="S10">))</span> это первое значение,
полученное из f, или <span class="S5">nil</span>, если f не возвращает значений.)<br /></p>

<h3><a name="2.5.1">2.5.1 – Арифметические операции</a></h3>

<p>Lua поддерживает обычные арифметические операции: двоичные <span class="S10">+</span> (сложение), <span class="S10">-</span> (вычитание), <span class="S10">*</span> (умножение),
<span class="S10">/</span> (деление), <span class="S10">%</span> (остаток от деления), и <span class="S10">^</span> (возведение в степень);
а также унарный минус <span  class="S10">-</span> (изменение знака числа). Если операнды являются числами или строками (которые могут быть преобразованы
в числа <a href="#2.2.1">§2.2.1</a>), то операции выполняются обычным образом. Возведение в степень работает для любого показателя степени. Например, x<span
 class="S10">^</span>(-0.5) подсчитывает величину, обратную квадратному корню из x.</p>


<h3><a name="2.5.2">2.5.2 – Операции сравнения</a></h3>

<p>Операции сравнения в Lua:</p>

<div class="contdiv"><pre><code class="lua">
	==    ~=    <     >     <=    >=
</code></pre></div>

<p>Эти операции всегда возвращают <b>false</b>
или <b>true</b>.</p>

<p>Сравнение на равенство (<span class="S10">==</span>)
сначала сравнивает типы операндов. Если типы различны, то результатом будет <b>false</b>. Иначе сравниваются значения операндов. Числа и строки сравниваются обычным способом. Объекты (таблицы,
пользовательские данные, потоки и функции) сравниваются по ссылке: два объекта считаются равными, только если они являются одним и тем же объектом. Создаваемый
объект (таблица, пользовательские данные, поток или функция) не может быть равен ни одному из уже существующих.</p>

<p>Правила преобразования из <a href="#2.2.1">§2.2.1</a> <em>НЕ</em> работают в
сравнениях на равенство. Например, <span class="S6">"0"</span><span class="S10">==</span><span class="S4">0</span>
вернет <b><span class="S5">false</span></b>, а t<span class="S10">[</span><span class="S4">0</span><span class="S10">]</span> и t<span class="S10">[</span><span class="S6">"0"</span><span class="S10">]</span>&nbsp;обозначают различные
записи в таблице.</p>

<p>Оператор <span  class="S10">~=</span> прямо противоположен оператору равенства (<span  class="S10">==</span>).</p>

<p>Операторы сравнения на больше-меньше работают следующим образом. Если оба параметра - числа, то они сравниваются как обычно. Если оба параметра строки,
то их значения сравниваются в соответствии с лексикографическим порядком. Во всех остальных ситуациях будет вызван метаметод (в данном руководстве не рассматривается).</p>


<h3><a name="2.5.3">2.5.3 – Логические операции</a></h3>

<p>В Lua это операции <b>and (и)</b>, <b>or (или)</b>, и <b>not (не)</b>. Так же, как и в управляющих конструкциях (<a href="#2.4.4">§2.4.4</a>), все логические операции
рассматривают <b>false</b> и <b>nil</b> как ложь, а все остальное как истину.</p>

<p>Операция отрицания <b>not</b> всегда возвращает <b>false</b> или <b> true</b>. Операция конъюнкции <b>and</b> возвращает
свой первый параметр, если его значение <b> false</b> или <b> nil</b>; в противном случае <b> and</b> возвращает
второй параметр. Оператор дизъюнкции <b> or</b> возвращает первый параметр, если его значение отлично от <b> nil</b> и <b>false</b>;
в противном случае <b> or</b> возвращает второй параметр. Оба оператора вычисляют второй операнд только в случае необходимости.</p>

<p>Примеры:</p>

<div class="contdiv"><pre><code class="lua">
    10 or 20            --> 10

    10 or error()       --> 10

    nil or "a"          --> "a"

    nil and 10          --> nil

    false and error()   --> false

    false and nil       --> false

    false or nil        --> nil

    10 and 20           --> 20
</code></pre></div>

<p>(В данном руководстве, --&gt; указывает на результат выражения.) </p>


<h3><a name="2.5.4">2.5.4 - Конкатенация</a></h3>

<p>Оператор конкатенации (соединения) строк в Lua обозначается двумя точками ('..').
Если оба операнда являются строками или числами, то они будут преобразованы в строки согласно правилам <a href="#2.2.1">§2.2.1</a>.
Иначе будет вызван метаметод (в данном руководстве не рассматривается).</p>


<h3><a name="2.5.5">2.5.5 – Получение длины</a></h3>

<p>Операция получения длины обозначается унарным <b>#</b>. В результате применения операции к строке возвращается количество байт (в обычном понимании
это длина строки, в которой каждый символ занимает 1 байт).</p>

<p>Длиной таблицы t считается любой целый индекс n такой, что t<span class="S10">[</span>n<span class="S10">]</span>
не равен <span class="S5">nil</span>, а t<span class="S10">[</span>n<span class="S10">+</span><span class="S4">1</span><span class="S10">]</span>
 равно <span class="S5">nil</span>. Кроме того, если t<span class="S10">[</span>
<span class="S4">1</span><span class="S10">]</span> равен <span class="S5">nil</span>, то
<span class="S10">#</span>t <span class="S10">=</span> <span class="S4">0</span>. Для регулярных
массивов от <span class="S4">1</span> до n, не содержащих значений <span class="S5">nil</span>,<span class="S0"> &nbsp;</span>длиной
является n, то есть индекс последнего значения. Если в массиве присутствуют  <b>"дыры"</b> (т.е., значения <span class="S5">nil</span> между
ненулевыми значениями), то значением <span class="S10">#</span>t является индекс элемента, непосредственно предшествующего
элементу <span class="S5">nil</span> (поэтому любое значение <span class="S5">nil</span> по сути означает конец массива).</p>


<h3><a name="2.5.6">2.5.6 – Приоритет операций</a></h3>

<p>Приоритет операций Lua показан на таблице ниже. Самым высоким приоритетом обладает операция возведения в степень, далее по убыванию:</p>

<div class="contdiv"><pre><code class="lua">
    or
    and
    <     >     <=    >=    ~=    ==
    ..
    +     -
    *     /     %
    not   #     - (unary)
    ^
</code></pre></div>

<p>Как обычно, для изменения порядка вычисления выражений вы можете использовать скобки. Конкатенация ('..') и
возведение в степень ('^') - правоассоциативные операторы. Все остальные бинарные операторы левоассоциативные.</p>


<h3><a name="2.5.7">2.5.7 – Конструкторы таблиц</a></h3>

<p>Конструкторы таблиц тоже относятся к выражениям. Обработка любого встречающегося в коде конструктора ведет к созданию новой таблицы. С помощью
конструкторов можно создать как пустые, так и частично либо полностью заполненные таблицы. Полное описание синтаксиса конструкторов:</p>

<div class="contdiv"><pre><code class="lua">
    tableconstructor::= '{' [fieldlist] '}'

    fieldlist::= field {fieldsep field} [fieldsep]

    field::= '[' exp ']' '=' exp | Name '=' exp | exp

    fieldsep::= ',' | ';'
</code></pre></div>

<p>Каждое поле вида
<span class="S10">[</span>exp1<span class="S10">]</span> <span class="S10">=</span>
 exp2 добавляет в новую
 таблицу значение exp2
с ключом exp1. Поле
вида name <span class="S10">=</span>
<span class="S14">exp</span> эквивалентно
<span class="S10">[</span><span class="S6">"name"</span><span class="S10">]</span>
<span class="S10">=</span> exp. Поле вида
 <span class="S14">exp</span> эквивалентно
<span class="S10">[</span>i<span class="S10">]</span> <span class="S10">=</span>
 <span class="S14">exp</span>, где
 i – целочисленный
автоинкрементный счетчик, начинающийся
с <span class="S4">1</span>. Поля
в других форматах не оказывают влияния на этот счетчик. Например, </p>

<div class="contdiv"><pre><code class="lua">
	a = { [f(1)] = g; "x", "y"; x = 1, f(x), [30] = 23; 45 }
</code></pre></div>

<p>эквивалентно </p>

<div class="contdiv"><pre><code class="lua">
	do
		local t = {}

		t[f(1)] = g

		t[1] = "x"

		t[2] = "y"

		t.x = 1

		t[3] = f(x)

		t[30] = 23

		t[4] = 45

		a = t

	end
</code></pre></div>

<p>Если последнее поле в списке задано в форме exp, и exp – это вызов функции или неопределенный
список параметров, то все значения, возвращаемые этим выражением, последовательно включаются в этот список (<a href="#2.5.8">§2.5.8</a>). Чтобы этого
избежать, необходимо заключить вызов функции (или список неопределенных параметров) в скобки (<a href="#2.5">§2.5</a>).</p>

<p>Список полей может оканчиваться разделителем, что улучшает читабельность машинно-генерируемого кода.</p>


<h3><a name="2.5.8">2.5.8 – Вызовы функций</a></h3>

<p>Вызовы функций в Lua имеют следующий синтаксис:</p>

<div class="contdiv"><pre><code class="lua">
	functioncall ::= prefixexp args
</code></pre></div>

<p>В вызове функции сначала вычисляются префиксное выражение и аргументы. Если
значение префиксного выражения имеет тип <em>function</em>, то эта функция будет вызвана с указанными
аргументами. В противном случае вызывается метаметод (в данном руководстве не рассматривается).</p>

<p>Форма записи</p>

<div class="contdiv"><pre><code class="lua">
	functioncall ::= prefixexp ':' Name args
</code></pre></div>

<p>может использоваться для вызова &quot;методов&quot;. Запись v:name
<span class="S10">(</span>args<span class="S10">)</span> синтаксически
аналогична записи v.name<span class="S10">
(</span>v<span class="S10">,</span>args<span class="S10">)</span>,
только v вычисляется
один раз.</p>

<p>Аргументы описываются следующим образом:</p>

<div class="contdiv"><pre><code class="lua">
	args ::= '(' [explist1] ')'

    args ::= tableconstructor

    args ::= String
</code></pre></div>

<p>Все выражения вычисляются перед вызовом. Вызов в<span class="S0">
</span>форме f<span class="S10">{</span>fields<span class="S10">}</span><span class="S0">
</span>синтаксически аналогичен f<span class="S10">
({</span>fields<span class="S10">})</span>; то
есть список аргументов<span class="S0"> &nbsp;</span>
является по сути новой<span class="S0">
</span>таблицей. Вызов в
форме f<span class="S7">'string'</span>
(или f<span class="S6">"string"</span>
или f<span class="S8">[[string]]</span>) синтаксически
 равен f<span class="S10">(</span><span class="S7">'string'</span>
<span class="S10">)</span>; в данном случае список аргументов -
единственная символьная строка.</p>

<p>Исключением в довольно свободном синтаксисе Lua является правило, по которому нельзя
переходить на новую строку непосредственно перед символом '(' в вызове функции. Это ограничение позволяет
избежать некоторой двусмысленности в языке. Если вы напишите </p>

<div class="contdiv"><pre><code class="lua">
	a = f

    (g).x(a)
</code></pre></div>

<p>Lua трактует эту<span class="S0">
</span>запись как выражение<span class="S0">
</span>a <span class="S10">=</span> f<span class="S10">
(</span>g<span class="S10">).</span>x<span class="S10">(</span>a<span class="S10">)</span>.
Поэтому, если вам нужно 2 выражения, вы должны добавить точку с запятой между ними. Если вы действительно хотите
вызвать f, вы необходимо убрать переход на новую строку перед (g).</p>

<p>Вызов в форме return<em> functioncall</em> называется
<em>концевым вызовом</em>. Lua также поддерживает <em>концевой вызов «себя» </em> (или <i>рекурсивный</i>
<em>концевой вызов</em>): в этом случае вызванная функция использует стек
вызывающей функции. Поэтому количество вложенных концевых вызовов может быть
любым. Заметим только, что концевой вызов стирает отладочную информацию о
вызывающей функции. Синтаксис концевого вызова допускает только единичный вызов
функции после оператора <b>return</b>.
Таким образом, <b>return</b> вернет в точности тот
результат, что вернет вызов функции. Ни один из представленных ниже примеров не
является допустимым концевым вызовом:</p>

<div class="contdiv"><pre><code class="lua">
    return (f(x))        -- список-результат обрезается

    return 2 * f(x)      -- удвоение результата функции

    return x, f(x)       -- возвращается несколько значений

    f(x); return         -- результат вызова отбрасывается

    return x or f(x)     -- список-результат обрезается
</code></pre></div>


<h3><a name="2.5.9">2.5.9 – Объявление функций</a></h3>

<p>Синтаксис объявления функций:</p>

<div class="contdiv"><pre><code class="lua">
    function ::= function funcbody

    funcbody ::= '(' [parlist1] ')' block end
</code></pre></div>

<p>Или в упрощенном виде</p>

<div class="contdiv"><pre><code class="lua">
    stat ::= function funcname funcbody

    stat ::= local function Name funcbody

    funcname ::= Name {'.' Name} [':' Name]
</code></pre></div>

<p>Выражение</p>

<div class="contdiv"><pre><code class="lua">
	function f () body end
</code></pre></div>

<p>транслируется в</p>

<div class="contdiv"><pre><code class="lua">
	f = function () body end
</code></pre></div>

<p>Выражение</p>

<div class="contdiv"><pre><code class="lua">
	function t.a.b.c.f () body end
</code></pre></div>

<p>транслируется в</p>

<div class="contdiv"><pre><code class="lua">
	t.a.b.c.f = function () body end
</code></pre></div>

<p>Выражение</p>

<div class="contdiv"><pre><code class="lua">
	local function f () body end
</code></pre></div>

<p>транслируется в</p>

<div class="contdiv"><pre><code class="lua">
	local f; f = function () body end
</code></pre></div>

<p><em>а</em><em> не</em><em> в</em></p>

<div class="contdiv"><pre><code class="lua">
	local f = function () body end
</code></pre></div>

<p>(Разница проявится в том случае, если в теле функции используется имя этой функции, например при рекурсивном вызове) </p>

<p>Объявление функции является выполняемым выражением, его результатом будет
значение типа <em>function</em>. Когда Lua прекомпилирует порцию, тела всех упоминающихся в ней функций также прекомпилируются. Таким
образом, всякий раз, когда Lua обрабатывает объявление функции, функция уже <i>конкретизирована</i> (или <i>замкнута</i>). Этот конкретный экземпляр функции
(или замыкание) и является конечным значением выражения «объявление функции». Различные
экземпляры одной и той же функции могу ссылаться на различные внешние локальные переменные и иметь различные таблицы окружения.</p>

<p>Параметры функции фактически являются локальными переменными, которые инициализированы входными значениями:</p>

<div class="contdiv"><pre><code class="lua">
	parlist1 ::= namelist [',' '...'] | '...'
</code></pre></div>

<p>В момент вызова функции длина списка передаваемых параметров приводится в соответствие спецификации, если это не <em>функция</em> с неопределенным
количеством параметров. Для функций с неопределенным количеством параметров такая коррекция не проводится; все входные параметры попадают в функцию в виде
<i>неопределенного выражения</i>, которое также обозначается с тремя точками. Значением этого выражения является список всех полученных входных параметров, как в случае
множественного результата функции. Если <i>неопределенное выражение</i> используется внутри другого выражения или в середине
списка выражений, то его значение-список урезается до одного элемента. Если это выражение стоит в конце списка выражений, урезания не происходит (если конечно
вызов не заключен в круглые скобки).</p>

<p>Рассмотрим следующие объявления:</p>

<div class="contdiv"><pre><code class="lua">
    function f(a, b) end

    function g(a, b, ...) end

    function r() return 1,2,3 end
</code></pre></div>

<p>Пример отображения входных значений на параметры функции:</p>

<div class="contdiv"><pre><code class="lua">
	ВЫЗОВ			ПАРАМЕТРЫ

	f(3)             a=3, b=nil

	f(3, 4)          a=3, b=4

	f(3, 4, 5)       a=3, b=4

	f(r(), 10)       a=1, b=10

	f(r())           a=1, b=2


	g(3)             a=3, b=nil, ... -->  (ничто)

	g(3, 4)          a=3, b=4,   ... -->  (ничто)

	g(3, 4, 5, 8)    a=3, b=4,   ... -->  5  8

	g(5, r())        a=5, b=1,   ... -->  2  3
</code></pre></div>

<p>Результаты возвращаются из функции оператором <b>return</b> (см. <a href="#2.4.4">§2.4.4</a>).
Если управление достигает конца функции, а оператор <b>return </b>не встретился, то функция завершается
и ничего не возвращает.</p>

<p><em>Синтаксис с двоеточием <b>‘:’</b></em> используется для определения <em>методов</em>. Эти
функции неявно получают параметр self в качестве первого аргумента. Таким образом, выражение</p>

<div class="contdiv"><pre><code class="lua">
	function t.a.b.c:f (params) body end
</code></pre></div>

<p>аналогично </p>

<div class="contdiv"><pre><code class="lua">
	t.a.b.c.f = function (self, params) body end
</code></pre></div>



<h2><a name="2.6">2.6 – Области видимости</a></h2>

<p>Lua язык с лексическим разграничением областей видимости. Область видимости переменной начинается первым выражением <i>после</i> ее
объявления и действует до конца блока, в котором это объявление встречается. Рассмотрим следующий пример:</p>

<div class="contdiv"><pre><code class="lua">
	x = 10                	-- глобальная переменная variable

	do                    	-- начало блока
		local x = x         -- объявление локальной переменной

		print(x)            --> 10

		x = x+1

		do                  -- начало вложенного блока
			local x = x+1   -- другая локальная 'x'

			print(x)        --> 12
		end

		print(x)            --> 11
	end

	print(x)              	--> 10  (глобальная переменная)
</code></pre></div>

<p>Отметим, что в объявлении local x = x локальная переменная объявляется еще не
в области своей видимости, поэтому присваивается именно внешняя переменная.</p>

<p>В соответствии с правилами лексического разграничения областей видимости, локальные
переменные доступны в функциях, определенных внутри их области видимости. Локальная
переменная, используемая в таких функциях, называется <i>внешней<em> локальной переменной
</em></i><em>(по отношению к определенной</em> внутри ее области видимости функции).</p>

<p>Обработка каждого объявления <b>local</b> ведет к созданию новой
локальной переменной. Рассмотрим следующий пример:</p>

<div class="contdiv"><pre><code class="lua">
	a = {}

	local x = 20

	for i=1,10 do

		local y = 0

		a[i] = function () y=y+1; return x+y end

	end
</code></pre></div>

<p>Цикл создает 10 экземпляров функции, в которых используются различные переменные
y и один и тот же x.</p>

<h2><a name="2.7">2.7 – Обработка ошибок</a></h2>

<p>Поскольку Lua является языком расширений, работа Lua начинается с момента
вызова в хост-программе функции из Lua-библиотеки (<a href="#lua_pcall">lua_pcall</a>). При
возникновении ошибки в процессе компиляции или выполнения Lua управление возвращается
в хост-программу, где и осуществляется ее обработка (например, вывод сообщения о ошибке).</p>

<p>Lua-код может явно генерировать ошибку, вызывая функцию <a href="#pdf-error">error</a>.
Если вам нужно перехватывать ошибки в самом Lua, вы можете использовать функцию <a href="#pdf-pcall">pcall</a>.</p>


<h2><a name="2.8">2.8 – Сборщик мусора</a></h2>

<p>Lua осуществляет автоматическое управление памятью. Это означает, что вам не нужно
думать о выделении памяти при создании новых объектов и ее освобождении, когда
объект становится ненужным. Lua время от времени автоматически запускает процедуру <i>сборки мусора
</i>для удаления <i>устаревших объектов</i> (то есть объектов, которые более недоступны из Lua).
Сборщик мусора обрабатывает все объекты Lua: таблицы, данные типа userdata, функции, потоки и строки.</p>



<h1><a name="3">3 - Использование Lua в программе GEDKeeper</a></h1>

<h2><a name="3.1">3.1 - Соглашения</a></h2>

<p>
Префикс "gk_" - обозначает функции общего назначения<br>
Префикс "gt_" - обозначает функции для работы с деревом<br>
</p>

<p>Типы данных:<br>
void - пустой аргумент или результат функции;<br>
int - целочисленный аргумент или результат функции;<br>
string - строковый аргумент или результат функции;<br>
boolean - логический аргумент или результат функции;<br>
</p>

<p>
Внимание:
	Все списки базы данных нумеруются от нуля, поэтому для перебора
	всех записей базы данных следует использовать, к примеру,
	такую конструкцию:
</p>

<div class="contdiv"><pre><code class="lua">
for i = 0, gt_get_records_count() - 1 do -- т.е. число элементов "-1"
	...
end
</code></pre></div>

<h2><a name="3.2">3.2 - Структуры данных</a></h2>

<p>Все действия над структурами данных базе выполняются посредством указателей (pointer) на эти структуры.
Указатель - специальная переменная, указывающая программе на ту или иную структуру в памяти.</p>

<p>
Указатели на структуры имеют следующие типы:
<ul>
<li>pointer (простой указатель)<ul>
	<li>record_pointer (указатель на запись)<ul>
		<li>person_pointer (указатель на запись персоны)</li>
		<li>family_pointer (указатель на запись семьи)</li>
		<li>note_pointer (указатель на запись заметки)</li>
		<li>source_pointer (указатель на запись источника)</li>
		<li>repository_pointer (указатель на запись архив)</li>
		<li>multimedia_pointer (указатель на запись мультимедиа-объекта)</li>
		<li>group_pointer (указатель на запись группы)</li>
		<li>research_pointer (указатель на запись исследования)</li>
		<li>task_pointer (указатель на запись задачи)</li>
		<li>commumication_pointer (указатель на запись коммуникаций)</li>
		<li>location_pointer (указатель на запись места)</li>
		</ul></li>
	</ul></li>
	<li>struct_pointer (указатель на структуру - вложенный объект записи)<ul>
		<li>association_pointer (указатель на ассоциацию)</li>
		<li>event_pointer (указатель на событие/факт)</li>
		</ul></li>
	</ul></li>
</ul>
</p>

<h2><a name="3.3">3.3 - Функции (API)</a></h2>

<p>
<dl>
	<dt>void gk_print(string text)</dt>
	<dd>вывод строки text;</dd>

	<dt>void gk_progress_init(int length, string title)</dt>
	<dd>показывает окно прогрессии, где length - число этапов прогрессии, title - заголовок;</dd>

	<dt>void gk_progress_done()</dt>
	<dd>скрывает окно прогрессии;</dd>

	<dt>void gk_progress_step()</dt>
	<dd>увеличивает число выполненных этапов прогрессии на один;</dd>

	<dt>int gk_strpos(string substr, string str)</dt>
	<dd>возвращает индекс первого вхождения подстроки substr в строке str;</dd>

	<dt>void gk_update_view()</dt>
	<dd>полностью обновляет вид всех списков (бывает необходимо после массовой обработки данных);</dd>
	
	<dt>string gk_select_file()</dt>
	<dd>открывает диалог выбора файла и возвращает строку с именем файла</dd>


	<dt>int gt_get_records_count()</dt>
	<dd>возвращает число записей в БД;</dd>

	<dt>record_ptr gt_get_record(int index)</dt>
	<dd>возвращает запись базы данных по заданному индексу.
	Внимание: записи различных типов располагаются в БД
	в произвольном порядке - так, как они вводились. Для
	обработки всех записей определенного типа, необходимо
	проверять их тип.</dd>

	<dt>int gt_get_record_type(record_ptr)</dt>
	<dd>возвращает код - числовую константу, определяющую тип записи;
	возможные варианты:<ul>
	<li>rtNone - тип не определяется либо неизвестен</li>
	<li>rtIndividual - персональная запись</li>
	<li>rtFamily - семья</li>
	<li>rtNote - заметка</li>
	<li>rtMultimedia - мультимедийная запись</li>
	<li>rtSource - запись источника</li>
	<li>rtRepository - архив или хранилище источников</li>
	<li>rtGroup - группа</li>
	<li>rtResearch - исследование</li>
	<li>rtTask - задача</li>
	<li>rtCommunication - коммуникации/переписка</li>
	<li>rtLocation - место</li>
	<li>rtSubmission - [зарезервировано (пока не используется)]</li>
	<li>rtSubmitter - исследователь базы данных</li>
	</ul></dd>

	<dt>string gt_get_record_type_name(int type)</dt>
	<dd>возвращает строку с идентификатором типа записи по его коду.</dd>

	<dt>string gt_get_record_xref(record_ptr)</dt>
	<dd>возвращает строку - идентификатор записи, обеспечивающий перекрестные ссылки между записями в базе</dd>

	<dt>string gt_get_record_uid(record_ptr)</dt>
	<dd>возвращает глобальный уникальный идентификатор записи в базе данных</dd>

	<dt>gt_delete_record(record)</dt>
	<dd>удаляет запись из базы данных</dd>

	<dt>boolean gt_record_is_filtered(record_ptr)</dt>
	<dd>возвращает логический признак, что данная запись отфильтрована и содержится в текущей отображаемой выборке</dd>


	<dt>string gt_get_person_name(record)</dt>
	<dd>возвращает полное имя персоны.</dd>


	<dt>int gt_get_person_associations_count(person_ptr)</dt>
	<dd>возвращает количество ассоциаций заданной персоны.</dd>

	<dt>ptr gt_get_person_association(person_ptr, int index)</dt>
	<dd>возвращает ассоциацию заданной персоны по индексу.</dd>

	<dt>gt_delete_person_association(person_ptr, index)</dt>
	<dd>удаляет ассоциацию персоны с заданным индексом.</dd>


	<dt>int gt_get_person_events_count(person_ptr)</dt>
	<dd>возвращает количество фактов персоны.</dd>

	<dt>event_ptr gt_get_person_event(person_ptr, int index)</dt>
	<dd>возвращает заданный индексом факт персоны.</dd>

	<dt>gt_delete_person_event(person_ptr, int index)</dt>
	<dd>удаляет заданный индексом факт персоны.</dd>


	<dt>string gt_get_event_value(event_ptr)</dt>
	<dd>возвращает строковое значение факта персоны.</dd>

	<dt>string gt_get_event_place(event_ptr)</dt>
	<dd>возвращает строку места факта персоны.</dd>

	<dt>string gt_get_event_date(event_ptr)</dt>
	<dd>возвращает строковое значение даты факта</dd>

	<dt>string gt_get_event_name(event_ptr)</dt>
	<dd>возвращает строку с именем-идентификатором типа факта (внимание - это внутренние идентификаторы фактов, см. <a href="">Идентификаторы типа факта</a>)</dd>


	<dt>person_ptr gt_create_person(string name, string patronymic, string family, string sex)</dt>
	<dd>создает новую персональную запись, где name-имя, patronymic-отчество, family-фамилия, sex-пол (варианты значений: "N"-не задан, "M"-мужской, "F"-женский, "U"-неопределенный)</dd>

	<dt>family_ptr gt_create_family()</dt>
	<dd>создает новую запись семьи</dd>

	<dt>gt_bind_family_spouse(family_ptr family, person_ptr spouse)</dt>
	<dd>присоединяет супруга "spouse" к семье "family". Внимание: у записи супруга должен быть задан пол, т.к. по нему автоматически определяется роль в семье.</dd>


	<dt>bool csv_load(string filename, bool first_line_is_schema)</dt>
	<dd>загрузить csv-таблицу, первый параметр определяет имя файла, второй - содержит ли первая строка файла заголовки колонок</dd>

	<dt>csv_close()</dt>
	<dd>закрыть csv-таблицу</dd>

	<dt>int csv_get_cols()</dt>
	<dd>получить количество столбцов в csv-таблице</dd>

	<dt>int csv_get_rows()</dt>
	<dd>получить количество строк в csv-таблице</dd>

	<dt>string csv_get_cell(col, row)</dt>
	<dd>получить содержимое ячейки в csv-таблице (столбцы и строки нумеруются от нуля)</dd>


	<dt>note_ptr gt_create_note()</dt>
	<dd>создать новую запись заметки</dd>

	<dt>gt_bind_record_note(record_ptr, note_ptr)</dt>
	<dd>присоединить к записи заметку</dd>

	<dt>gt_add_note_text(note_ptr, string text)</dt>
	<dd>добавляет в запись заметки текстовую строку</dd>

	<dt>record_ptr gt_select_record(int record_type)</dt>
	<dd>вызывает диалог выбора записи из имеющихся</dd>

	<dt>gt_bind_record_source(record_ptr, source_ptr, string page, int quality)</dt>
	<dd>присоединяет к любой записи заданный источник, устанавливает страницу (page) и качество источника (quality, 0..3)</dd>

	<dt>string gt_define_sex(string name, string patronymic)</dt>
	<dd>возвращает идентификатор пола, определенный по имени и отчеству</dd>

	<dt>gt_set_event_place(event_ptr, string place)</dt>
	<dd>установить факту свойство места</dd>

	<dt>source_record gt_create_source(string name)</dt>
	<dd>создает новый источник с заданным названием</dd>

	<dt>source_record gt_find_source(string name)</dt>
	<dd>ищет в списке источник с требуемым названием</dd>

	<dt>event_ptr gt_create_event(record_ptr, string sign)</dt>
	<dd>создать новый факт в записях персон или семей, где sign - строковый тип факта</dd>

	<dt>gt_set_event_date(event_ptr, string date)</dt>
	<dd>установить факту дату</dd>

	<dt>gt_bind_family_child(family_ptr, person_ptr child)</dt>
	<dd>присоединить к семье ребенка</dd>

	<dt>association_ptr gt_add_person_association(person_ptr, string relation, person_ptr rel_person)</dt>
	<dd>добавяет персоне person_record, ссылку-ассоциацию на персону rel_person.
	Используется, к примеру, когда нужно сделать ссылки на крестных.</dd>

	<dt>string gt_define_patronymic(string father_name, string child_sex, bool confirm)</dt>
	<dd>определяет при помощи встроенного словаря отчество ребенка с полом child_sex по имени отца father_name.
	Параметр confirm(true|false) определяет - спрашивать ли пользователя в сомнительных случаях.</dd>

	<dt>family_record gt_get_person_parents_family(person_ptr)</dt>
	<dd>возвращает семью родителей данной персоны</dd>

	<dt>int gt_get_person_spouses_count(person_ptr)</dt>
	<dd>возвращает число супругов данной персоны</dd>

	<dt>family_ptr gt_get_person_spouse_family(person_ptr, int index)</dt>
	<dd>возвращает семью данной персоны и его(её) супруги, index - определяет номер брака</dd>

	<dt>person_ptr gt_get_family_husband(family_ptr)</dt>
	<dd>возвращает персону мужа данной семьи</dd>

	<dt>person_ptr gt_get_family_wife(family_ptr)</dt>
	<dd>возвращает персону жены данной семьи</dd>

	<dt>int gt_get_family_childs_count(family_ptr)</dt>
	<dd>возвращает число детей в данной семье</dd>

	<dt>person_ptr gt_get_family_child(family_ptr, int index)</dt>
	<dd>возвращает персону ребенка заданной семьи по его номеру</dd>
</dl>
</p>

</body>
</html>
