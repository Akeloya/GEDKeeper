<html>

<head>

<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
<title>Справка GEDKeeper. Использование скриптов</title>
<link rel="stylesheet" href="style.css" type="text/css" />
<link rel="stylesheet" href="default.css" type="text/css" />

<script src="highlight.pack.js"></script>
<script>
  hljs.tabReplace = '    ';
  hljs.initHighlightingOnLoad();
</script>

</head>

<body>

<table><tr><td class="maincont" height="100%">

<h1>1 - Введение в Lua</h1>

<p class="contpara">Lua является типичным процедурным языком программирования. Он предоставляет
широкие возможности для объектно-ориентированной и функциональной разработки. Lua создавался
как мощный и простой язык, обладающий всеми необходимыми выразительными средствами.</p>

<p class="contpara">Будучи расширяемым языком, Lua не имеет понятия &quot; main &quot; программы: 
он работает в среде исполнения, сокращенно называемой <b class="contbold">хост</b>. Хост-программа позволяет
запускать части кода, написанные на Lua, модифицировать переменные Lua и регистрировать С-функции для
использования непосредственно в коде Lua. Благодаря возможности расширения с помощью С-функций, Lua может
применяться для решения широкого круга задач. Таким образом, мы имеем возможность создавать 
специализированные библиотеки, использование которых ничем не отличается от использования 
стандартных средств языка.</p>

<p class="contpara">Lua является свободно распространяемым программным средством, поэтому
предоставляется без каких либо гарантий в соответвие с лицензией. Версия <b class="contbold">lua 5.1</b>, которая
описана в данном Руководстве, доступна на официальном сайте Lua <b class="contbold">www.lua.org</b></p>

<p class="contpara">Как и многие подобные Руководства, этот документ написан в формальном стиле.
Для получения более подробной информации об особенностях применения языка
рекомендуем обратиться к технической документации, доступной на официальном
сайте Lua. Хорошим подспорьем в работе может оказаться книга Роберта Иерусалимского (Roberto Ierusalimschy)
«Программирование на Lua», второе издание <em>(Programming in Lua (Second Edition))</em>.</p>


<h1>2 – Описание языка Lua</h1>

<p class="contpara">В этой главе описывается лексика, синтаксис и семантика языка Lua. Другими словами, здесь
представлены элементы языка, способы их комбинирования и значение языковых конструкций. </p>

<p class="contpara">Конструкции языка будут вводится с использованием расширенной BNF, 
где запись {<em>a</em>} означает 0 или более элементов <em>a</em>, а запись [<em>a</em>] означает его 
необязательное вхождение. Нетерминальные символы отображаются обычным шрифтом, ключевые слова
выделяются жирным шрифтом <b class="contbold">kword</b>, все остальные терминальные символы заключаются 
в апострофы `<b class="contbold">=</b>?.</p>


<h2>2.1 – Лексические соглашения</h2>

<p class="contpara"><em>Именами</em> (<i style='contitalic'>идентификаторами</i>)
в Lua могут быть любые строки из букв, цифр и символа подчеркивания, не начинающиеся с
цифры. Это правило типично для большинства языков программирования. (Понятие
буквы зависит от текущей локали: любой символ из алфавита текущей локали может
быть использован в составе идентификатора). Идентификаторы используются для
именования переменных и таблиц значений (table fields). </p>

<p class="contpara">Следующие <i style='contitalic'>ключевые слова </i>зарезервированы
и не могут быть использованы в именах: </p>

<div class="contdiv"><pre><code class="lua">
and      break       do     else    elseif
end      false      for    function   if
in       local      nill     not      or
repeat   return   then   true   until   while
</code></pre></div>

<p class="contpara">Lua является языком, чувствительным к регистру символов: and –
ключевое слово, тогда как And и AND– два разных допустимых идентификатора. По соглашению, имена,
начинающиеся с символа подчеркивания и записанные в верхнем регистре (например _VERSION),
зарезервированы для использования в качестве внутренних глобальных переменных,
используемых Lua. </p>

<p class="contpara">В следующих строках показаны другие допустимые символы: </p>

<div class="contdiv"><pre><code class="lua">
+   *   /   %   ^   <   #   <o:p></o:p>
==   ~=   &lt;=   &gt;=   &lt;   &gt;   =<o:p></o:p>
(   )   {   }   [   ]<o:p></o:p>>
;   :   ,   .    ..   ...<o:p></o:p>
</code></pre></div>

<p class="contpara"><em>Литеральные строки </em><em>должны быть заключены в одинарные или двойные кавычки и</em> могут
содержать следующие С-подобные escape-поледовательности:
'\a' («звонок»), '\b' («забой»), '\f' («перевод страницы»),
'\n' («перевод на новую строку»), '\r' («возврат каретки»), 
'\t' («горизонтальная табуляция»), '\v' («вертикальная табуляция»), 
'\\\&quot;' («двойная кавычка»), and'\'' (апостроф [«одинарная кавычка»]). Кроме
того, обратный слеш ставится перед концом строки в редакторе, когда для
удобства набора длинные непрерывные строки записываются в несколько строк. Символ
в строке также может быть представлен своим кодом с помощью escape-последовательности \<em>ddd</em>, где <em>ddd</em>-
последовательность из не более чем трех цифр. (Заметим, что если после символа,
записанного с помощью своего кода, должна идти цифра, то код символа в escape-последовательности
должен содержать ровно три цифры). Строки в Lua могут содержать любые 8-битные
значения, включая ноль, который записывается как '\0'. <o:p></o:p></p>

<p class="contpara">Чтобы поместить одни двойные кавычки, символы новой строки, 
обратный слэш, или нулевой символ в строку, ограниченную двойными кавычками вы 
должны использовать escape-последовательности. Любой другой символ
может быть напрямую включен в строку.</p>

<p class="contpara">Символьные строки могут также определяться используя длинный формат, ограниченный <em>длинными скобками</em>. 
Мы определяем <em>открывающую длинную скобку уровня n</em> как открывающую квадратную скобку следующую за <em>n</em>
знаками равенства следующими за другой открывающей квадратной скобкой. Так, открывающая длинная скобка уровня &nbsp;0 
записывается как [[, открывающая длинная скобка уровня &nbsp;1 записывается как [=[, и так далее. 
<em>Закрывающая длинная скобка</em> отпределяется также; для примера, закрывающая скобка уровня &nbsp;4 
записывается как ]====]. Длинные строки начинаются с
открывающей длинной скобки любого уровня и заканчиваются первой закрывающей длинной скобкой 
соответствующего уровня. Литералы в такой форме могут находится в разных строках, escape-последовательности
не интерпретируются, и игнорируются длинные скобки любого другого уровня. 
Они могут содержать что угодно, исключая закрывающую скобку соответствующего уровня. <o:p></o:p></p>

<p class="contpara">Для удобства, когда открывающая длинная скобка следует непосредственно в новой линии, 
эта линия не включается в строку. Для примера, в системе использующей ASCII (в которой 'a' кодируется как &nbsp;97, 
новая строка как &nbsp;10, и '1' как &nbsp;49), пять литералов ниже обозначают одну строку: <o:p></o:p></p>

<div class="contdiv">
<pre>     a <span class="S10">= '</span> alo<span class="S10">\</span>n123&quot;<span class="S10">'</span></pre><pre>     a <span class="S10">=</span> &quot;alo<span class="S10">\</span>n123<span class="S10">\</span>&quot;&quot;</pre><pre>     a <span class="S10">=</span> '<span class="S10">\</span>97lo<span class="S10">\</span>10<span class="S10">\</span>04923&quot;'</pre><pre>     a <span class="S10">= [[</span>alo</pre><pre>     123&quot;<span class="S10">]]</span></pre><pre>     a <span class="S10">= [==[</span></pre><pre>     alo</span></pre><pre>     123&quot;<span class="S10">]==]</span></pre>
</div>

<p class="contpara"><em>Числовая константа</em> может быть записана с опциональной деятичной частью 
и опциональной десятичной экспонентой. Lua также принимает целый шестадцатиричные константы, с префиксом 0x. 
Примеры правильных числовых констант <o:p></o:p></p>

<pre><o:p>&nbsp;</o:p></pre><pre>     3   3.0   3.1416   314.16e-2   0.31416E1   0xff   0x56<o:p></o:p></pre>

<p class="contpara"><em>Комментарий</em> начинается с двойного дефиса (--) везде за пределами строки. 
Если текст непосредственно после -- не содержит длинную открывющую скобку [, 
комментарий является <em>коротким</em>, который продолжается до конца строки.
Иначе, это <em>длинный комментарий</em>, который продолжается пока не встретится
закрывающая длинная скобка ]. Длинный комментарий часто встречается для временной деактивации кода. <o:p></o:p></p>


<h2>2.2 – Значения и типы</h2>

<p class="contpara">Lua представляет собой язык с <i>динамическим
определением типов данных</i>. Переменная языка может содержать значения любого
типа. Возможности определения пользовательских типов данных отсутствуют. Все значения
в Lua могут храниться в переменных, использоваться в качестве аргументов при вызове функций
и возвращаться в виде результата их выполнения. </p>

<p class="contpara">В Lua восемь основных типов: <em>nil (неопределенный)</em>, <em>boolean (логический)</em>, 
<em>number (числовой)</em>, <em>string (строковый)</em>, <em>function (функция)</em>, 
<em>userdata (пользовательские данные)</em>, <em>thread (поток)</em>, и <em>table (таблица)</em>.

<em>Nil - </em>это тип значения <b class="contbold">nil [пустое значение]</b>, главное свойство
которого – отличаться от всех остальных значений и обозначать отсутствие
пригодного значения. К типу <em>Boolean</em> относятся значения <b class="contbold">false</b> (ложь) и <b class="contbold">true </b>(истина). Значения <b class="contbold">nil</b> и
<b class="contbold">false</b> считаются ложными, любое другое значение считается истинным.
К типу <em>Number</em> относятся вещественные числа (двойной точности с плавающей запятой). 
Тип <em>String </em><em>обозначает</em> массивы символов. Строки Lua могут содержать
любые 8 битные символы, включая ноль ('\0') (смотреть <a href="/doc/2.1.html">§2.1</a>). </p>

<p class="contpara">В Lua можно использовать функции, написанные на Lua и на C 
(смотреть <a href="/doc/2.5.8.html">§2.5.8</a>).</p>

<p class="contpara">Тип <em>userdata (пользовательские данные) </em> позволяет хранить любые данных 
из C в переменных Lua. Значение этого типа является
ссылкой на блок физической памяти и не имеет предопределенных операций в Lua, за исключением
присваивания и проверки на равенство. Однако, используя <em>метатаблицы</em>, програмист
может определить операции над значениями этого типа (смотрите <a href="/doc/2.8.html">§2.8</a>).
Значения типа userdata не могут быть созданы или изменены непосредственно в Lua, это возможно только 
с помощью C&nbsp;API. Такой подход гарантирует целостность данных, принадлежащих ведущей программе. </p>

<p class="contpara">Тип <em>thread (поток)</em> обозначает независимый поток исполнения и используется
при реализации механизма сопрограмм (смотрите <a href="/doc/2.11.html">§2.11</a>). Нельзя
отождествлять потоки Lua с потоками операционной системы. Lua поддерживает
подпрограммы даже в тех системах, где потоки на уровне операционной системы не
поддерживаются. </p>

<p class="contpara">Тип <em>table (таблица)</em> определяет ассоциативные массивы. Такие
массивы могут индексироваться не только числами, но и любыми значениями (за
исключением <b class="contbold">nil</b>). Таблица может содержать значения  сразу
нескольких типов (кроме <b class="contbold">nil</b>). Таблицы представляют собой единственный механизм 
структурирования данных в Lua;  они могут использоваться как простые массивы,
таблицы сиволов, множества, поля записей, деревья и так далее. Для представления словарей Lua использует
имя поля в качестве индекса таблицы. Представление в виде a.name считается тождественным представлению a[&quot;name&quot;]. В Lua есть несколько
способов создания таблиц (смотреть <a href="/doc/2.5.7.html">§2.5.7</a>).<o:p></o:p></p>

<p class="contpara">Индексы и значения полей таблицы могут быть любого типа (кроме <b class="contbold">nil</b>).
В частности, так как функции являются значениями встроенного типа, поля таблицы могут содержать и
функции. Таким образом, таблицы могут хранить методы <em>methods</em> (смотреть <a
href="#_2.5.9_–_Определение_функций">§2.5.9</a>). </p>

<p class="contpara">Переменные типа <i>table</i>, <i>function</i>, <i>thread</i> и <i>userdata</i> не
содержат самих данных, в них хранятся только ссылки на соответствующий объект. Присваивание,
передача параметров и возврат результата из функции оперируют только ссылками
на значения, эти операции никогда не ведут к созданию копий.</p>

<p class="contpara">Библиотечная функция <a href="#pdf-type"><span lang=EN-US
style='font-size:10.0pt;mso-ansi-language:EN-US'>type</span></a> возвращает
строку, описывающую тип данного значения. </p>


<h3>2.2.1 – Приведение типов</h3>

<p class="contpara">Lua обеспечивает автоматическое преобразование между строковыми и числовыми значениями
в процессе выполнения. Любая арифметическая операция, применяемая к строке, пытается
преобразовать эту строку в соответствующее число по обычным правилам приведения.
Когда же число используется там, где ожидается строка, это число преобразуется в
строку в произвольном подходящем формате. Так что для получения какого-то
конкретного представления числа в строке необходимо использовать функцию <span style='font-size:10.0pt;'>format</span> из библиотеки работы со строками (смотрите <a
href="#pdf-string.format"><span  style='font-size:10.0pt;'> string</span><span style='font-size:10.0pt'>.</span><span
lang=EN-US style='font-size:10.0pt;'>format</span></a>).</p>


<h2>2.3 - Переменные</h2>

<p class="contpara">Переменные используются для хранения значений в процессе выполнения
программы. В Lua есть три вида переменных: глобальные, локальные и поля таблиц.</p>

<p class="contpara">Отдельный идентификатор может обозначать глобальную или локальную переменную
(либо формальный параметр функции, что является частным случаем локальной переменной) :</p>

<div class="contdiv"><pre><code class="lua">
var ::= Name Имя
</code></pre></div>

<p class="contpara">Где Name<span lang=EN-US> </span>– идентификатор, определяемый в соответствии с 
<a href="/doc/2.1.html">§2.1</a>.</p>

<p class="contpara">Любая переменная считается глобальной, если она явно не объявлена как
локальная (смотрите <a href="/doc/2.4.7.html">§2.4.7</a>). Локальные переменные
существуют в лексическом контексте: локальные переменные доступны функциям,
определенным внутри этого контекста (смотрите <a href="/doc/2.6.html">§2.6</a>). </p>

<p class="contpara">До первого явного присвоения значением переменной является <b class="contbold">nil</b>. </p>

<p class="contpara">Квадратные скобки используются для доступа к элементу таблицы по индексу: </p>

<div class="contdiv"><pre><code class="lua">
var ::= prefixexp '[' exp ']'
</code></pre></div>

<p class="contpara">Способ доступа к глобальным переменным и полям таблицы может быть изменен с
помощью мететаблиц. Доступ к переменной t[i] эквивалентен вызову gettable_event(t,i). (Полное описание функции gettable_event смотрите в
<a href="/doc/2.8.html">§2.8</a>. Эта функция недоступна в коде Lua, мы упоминули ее здесь в качестве
примера). </p>

<p class="contpara">Запись var.Name аналогична записи var[&quot;Name&quot;]:</p>

<div class="contdiv"><pre><code class="lua">
var ::= prefixexp '.' Name
</code></pre></div>

<p class="contpara">Все глобальные переменные являются полями в обычных таблицах Lua, называемых таблицами 
окружения или кратко окружениями (смотреть <a href="/doc/2.9.html">§2.9</a>). Каждая функция имеет ссылку 
на свое собственное окружение, и все глобальные переменные внутри этой функции ссылаются на данную
таблиц. В момент создания функция наследует окружение вызывающей функции. Для получения
таблицы окружения функии Lua можно вызвать функцию <a href="#pdf-getfenv">getfenv</a>.
Для перезаписи таблицы используется <a href="#pdf-setfenv">setfenv</a>.
(Вы можете манипулировать окружением C&nbsp; функций только с помощью отладочной библиотеки (смотрите <a
href="/doc/5.9.html">§5.9</a>).) </p>

<p class="contpara">Обращение к глобальной переменной x эквивалентно _env.x, а также </p>

<div class="contdiv"><pre><code class="lua">
gettable_event(_env, "x")
</code></pre></div>

<p class="contpara">где _env –
окружение выполняющейся функции. (Полное описание функции gettable_event смотрите в</span> <a href="/doc/2.8.html">§2.8</a> . Эта
функция недоступна в коде Lua, мы упоминули ее здесь в качестве примера).</p>


<h2>2.4 – Операторы</h2>

<p class="contpara">В Lua поддерживается в общем стандартный набор операторов, почти
как в Pascal или C. Он состоит из операторов присваивания, операторов управления потоком исполнения,
вызова функций и описания переменных. </p>


<h3>2.4.1 – Порции</h3>

<p class="contpara">Единица исполнения Lua называется <em>chunk (порция</em>). Порция – это любая 
последовательность операторов Lua. Операторы в порции могут разделяться запятыми: </p>

<div class="contdiv"><pre><code class="lua">
chunk ::= {stat [';']}
</code></pre></div>

<p class="contpara">Пустого оператора в языке нет, поэтому выражение ';;' не допустимо. </p>

<p class="contpara">Lua воспринимает порцию как неименованную функцию с произвольным набором
параметров (смотрите <a href="/doc/2.5.9.html">§2.5.9</a>). Порция может определять локальные
переменные и возвращать значения.</p>

<p class="contpara">Порция может храниться в файле или в строке базовой программы. В момент
запуска порции на выполнение осуществляется компиляция ее в промежуточный
байт-код (инструкции для виртуальной машины). Затем полученный код исполняется
виртуальной машиной. </p>


<h3>2.4.2 – Блоки</h3>

<p class="contpara">Блок это список операторов; синтаксически блок тождественно равен порции (chunk) : </p>

<div class="contdiv"><pre><code class="lua">
block ::= chunk
</code></pre></div>

<p class="contpara">Блок операторов может быть явно ограничен, таким образом представляется составной оператор: </p>

<div class="contdiv"><pre><code class="lua">
stat ::= do block end
</code></pre></div>

<p class="contpara">С помощью составных операторов можно ограничивать области видимости локальных
переменных. Также составные операторы используются в циклах и условном
операторе (смотрите <a href="/doc/2.4.4.html">§2.4.4</a>). </p>


<h3>2.4.3 – Присваивание</h3>

<p class="contpara">Lua поддерживает параллельное присваивание. В общем случае, оператор
присваивания выглядит как список переменных, символ ‘=’ и список выражений.
Элементы списков указываются через запятую: </p>

<div class="contdiv"><pre><code class="lua">
	stat ::= varlist1 '=' explist1
       
    varlist1 ::= var {',' var}
     
    explist1 ::= exp {',' exp}
</code></pre></div>

<p class="contpara">Выражения (exp) рассмотрены в <a href="/doc/2.5.html">§2.5</a>. </p>

<p class="contpara">Перед выполнением присваивания список переменных согласовывается по длине со
списком выражений. Если список справа длиннее, то его лишние элементы просто отбрасываются. Если короче, то недостающие
позиции дополняются значениями <b class="contbold">nil</b>. Если список операторов оканчивается вызовом функции, то
перед согласованием все возвращаемые оттуда значения вставляются в правый списк
(за исключением случаев, когда вызов взят в скобки; смотрите <a href="/doc/2.5.html">§2.5</a>).</p>

<p class="contpara">Перед выполнением присваивания вычисляется значение всех выражений. Код</p>

<div class="contdiv"><pre><code class="lua">
	i = 3

    i, a[i] = i+1, 20
</code></pre></div>

<p class="contpara">означает, что переменной a[3] присваивается значение 20, потому что i в
выражении a[i] имеет то же самое значение, что и в момент вычисления выражения i+1.
Аналогично, строка</p>

<div class="contdiv"><pre><code class="lua">
x, y = y, x
</code></pre></div>

<p class="contpara">является простым способом обмена значениями двух переменных.(при
«традиционном» способе требуется дополнительная переменная)</p>

<p class="contpara">Действие операции присваивания для глобальных переменных и полей таблиц может
быть переопределено посредством метатаблиц. Присваивание индексной переменной t<span class="S10">[</span>i<span class="S10">]</span><span class="S0"> </span><span class="S10">=</span><span class="S0"> </span>val<span class="S0"> </span>эквивалентно<span class="S0"> </span>вызову<span class="S0"> </span>settable_event<span class="S10">(</span>t<span class="S10">,</span>i<span class="S10">,</span>val<span class="S10">)</span>. (Полное описание функции settable_event смотрите в

<a href="/doc/2.8.html">§2.8</a>. Эта функция недоступна в коде Lua, мы упоминули ее здесь в качестве
примера.) </p>

<p class="contpara">Присваивание к глобальной переменной x<span class="S10">=</span>val эквивалентно присваиванию _env.x=val, то же самое
произойдет при вызове</p>

<div class="contdiv"><pre><code class="lua">
	settable_event(_env, "x", val)
</code></pre></div>

<p class="contpara">где _env окружение запущенной функции. (Переменная _env недоступна в Lua,
мы приводим ее здесь в качестве примера. ) </p>


<h3>2.4.4 – Управляющие конструкции</h3>

<p class="contpara">Операторы <b class="contbold">if</b>, <b class="contbold">while</b>, и <b class="contbold">repeat</b> 
имеют обычное значение и знакомый синтаксис: </p>

<div class="contdiv"><pre><code class="lua">
	stat ::= while exp do block end
     
    stat ::= repeat block until exp
     
    stat ::= if exp then block {elseif exp then block} [else block] end
</code></pre></div>

<p class="contpara">В Lua также имеется выражение <b class="contbold"> for </b>в двух
вариантах (смотрите <a href="/doc/2.4.5.html">§2.4.5</a>). </p>

<p class="contpara">Логическое выражение в управляющих конструкциях может возвращать любое значение.
Значения <b class="contbold">false</b> и <b class="contbold">nil</b> считаются ложными. Все остальные значения считаются
истинными (в том числе значение 0 и пустая строка !). </p>

<p class="contpara">Цикл <b class="contbold">repeat</b>–<b class="contbold">until</b> канчивается условием, идущим следом
за <b class="contbold">until,</b> поэтому
в условии можно ссылаться на локальные переменные, описанные внутри цикла. </p>

<p class="contpara">Выражение <b class="contbold">return</b> используется для того, чтобы возвратить значения из функции или
порции. Синтаксис оператора <b class="contbold">return</b> позволяет функции или порции вернуть несколько
значений: </p>

<div class="contdiv"><pre><code class="lua">
	stat ::= return [explist1]
</code></pre></div>

<p class="contpara">Оператор <b class="contbold">break</b> используется для досрочного выхода из циклов <b class="contbold">while</b>, <b class="contbold">repeat</b> и <b class="contbold">for</b>: </p>

<div class="contdiv"><pre><code class="lua">
stat ::= break
</code></pre></div>

<p class="contpara"><b class="contbold">Break</b> прерывает цикл, в теле которого встречается, внешние циклы
продолжают выполнение. </p>

<p class="contpara"><b class="contbold">Return</b> (или <b class="contbold">break)</b>
должен быть <i class="contitalic">последним</i> оператором в
блоке (иначе следующие за ним операторы никогда не выполнятся). Если действительно
необходимо вставить <b class="contbold">return</b> или <b class="contbold">break</b> в середину блока, 
то следует применить составной оператор, например do return end и do break end. </p>


<h3>2.4.5 – Оператор For</h3>

<p class="contpara">Оператор <b>for</b> допускает простую и расширенную формы записи. </p>

<p class="contpara">В простой форме <b>for</b> выполняет блок кода до тех пор, пока переменная цикла,
изменяеющаяся в арифметической прогрессии, не достигнет установленного порога. </p>

<div class="contdiv"><pre><code class="lua">
	stat ::= for Name ' = ' exp1 ',' exp2 [', ' exp3] do block end
</code></pre></div>

<p class="contpara"><em>block</em> повторяется для переменной цикла <em>name</em> начиная
со значения выражения <em>exp1</em>, до тех пор пока выполняется выражение <em>exp2</em> с
шагом выражения <em>exp3</em>.
</p>

<p class="contpara">Таким образом, запись </p>

<div class="contdiv"><pre><code class="lua">
	for v = e1, e2, e3 do block end
</code></pre></div>

<p class="contpara">эквивалентна коду</p>

<div class="contdiv"><pre><code class="lua">
	do
		local var, limit, step = tonumber(e1), tonumber(e2), tonumber(e3)

		if not (var and limit and step) then error() end

		while (step > 0 and var <= limit) or (step <= 0 and var >= limit) do

			local v = var

			block

			var = var + step
		end
    end
</code></pre></div>

<p class="contpara">Обратите внимание, что:</p>

<ul type=disc class="contul">
 <li>Все три логических выражения вычисляются только один раз перед началом цикла, причем полученные
     значения должны быть числами. </li>

 <li><em>var</em>, <em>limit</em>, и <em>step</em> - неявные переменные,
     мы условно именовали их здесь для объяснения логики работы </li>

 <li>Если выражение step (шаг) отсутствует, то по умолчанию используется 1 </li>

 <li>Для выхода из цикла <b>for</b> используйте <b>break</b>. </li>

 <li>Переменная <b>v</b> является локальной для цикла; вы не сможете использовать ее значение после выхода
     из цикла <b>for</b>. Если вам необходимо значение этой переменной, присвойте его другой
     переменной перед выходом из цикла. </li>
</ul>

<p class="contpara">Расширенная форма оператора <b>for</b> реализована с использованием функций
<i>итераторов</i>. На каждом обороте для получения нового значения переменной цикла вызывается <i>итератор</i>. 
Цикл заканчивается, когда <i>итератор </i>вернет <b>nil</b>. Синтаксис расшеренного оператора <b>for</b>: </p>

<div class="contdiv"><pre><code class="lua">
	stat ::= for namelist in explist1 do block end

    namelist ::= Name {', '~ Name}
</code></pre></div>

<p class="contpara">Запись</p>

<div class="contdiv"><pre><code class="lua">
	for var_1, ···, var_n in explist do block end
</code></pre></div>

<p class="contpara">можно представить как</p>

<div class="contdiv"><pre><code class="lua">
	do
		local f, s, var = explist

		while true do
			local var_1, ···, var_n = f(s, var)

			var = var_1

			if var == nil then break end

			block
		end
    end
</code></pre></div>

<p class="contpara">Заметим, что</p>

<ul type=disc class="contul">
 <li><em>explist</em> вычисляется только однажды. Его результатом является функция-<i>итератор, </i>таблица состояний и начальное значение индекса </li>

 <li><em>f</em>, <em>s</em>, и <em>var</em> неявные переменные, именованные здесь для примера </li>

 <li>Выйти из цикла можно с помощью оператора <b>break</b>.</li>

 <li>Переменная <em>var</em><em>_</em><em>i</em> является локальной; вы не
     сможете использовать ее значение после выхода из <b>for</b>. Если вам необходимо ее
     значение, заранее сохраните его в другой переменной. </li>
</ul>


<h3>2.4.6 – Вызов функции</h3>

<p>Для создания побочных эффектов может быть полезен вызов функций,
используемый в качестве оператора:</p>

<div class="contdiv"><pre><code class="lua">
	stat ::= functioncall
</code></pre></div>

<p>В этом случе все возвращаемые значения отбрасываются. Вызовы функций рассматриваются
в <a href="/doc/2.5.8.html">§2.5.8</a>. </p>


<h3>2.4.7 – Локальные объявления</h3>

<p>Локальные переменные могут быть объявлены где угодно внутри блока. Объявление
может включать инициализацию: </p>

<div class="contdiv"><pre><code class="lua">
	stat ::= local namelist ['=' explist1]
</code></pre></div>

<p>Инициализация обладает всеми свойствами операции присваивания (в том числе
параллельностью) (смотрите <a href="/doc/2.4.3.html">§2.4.3</a>). По умолчанию все переменные
инициализируются значением <b>nil</b>.</p>

<p>Порция является блоком (смотрите <a href="/doc/2.4.1.html">§2.4.1</a>), поэтому локальные
переменные могут быть объявлены вне любого явно заданного блока. Областью действия
таких локальных переменных являются границы порции. </p>

<p>Правила видимости для локальных переменных рассмотрены в <a href="/doc/2.6.html">§2.6</a>.</p>


<h2>2.5 - Выражения</h2>

<p class="contpara">Выражениями в Lua являются следующие конструкции: </p>

<div class="contdiv"><pre><code class="lua">
	exp ::= prefixexp

    exp ::= nil | false | true

    exp ::= Number

    exp ::= String

    exp ::= function

    exp ::= tableconstructor

    exp ::= '...'

    exp ::= exp binop exp

    exp ::= unop exp

    prefixexp ::= var | functioncall | '(' exp ')'
</code></pre></div>

<p class="contpara">Числа и символьные строки рассмотрены в <a href="/doc/2.1.html">§2.1</a>; переменные -
в <a href="/doc/2.3.html">§2.3</a>; описания функций - в <a href="/doc/2.5.9.html">§2.5.9</a>; вызовы
функций - в <a href="/doc/2.5.8.html">§2.5.8</a>; конструкторы таблиц - в <a
href="/doc/2.5.7.html">§2.5.7</a>. Неявные аргументы, обозначаемые ‘...', могут использоваться только внутри
соответственно заданной функции; смотрите <a href="/doc/2.5.9.html">§2.5.9</a>. </p>

<p class="contpara">К бинарным операциям (binop в формальном определении выражения) относятся арифметические
(смотрите <a href="/doc/2.5.1.html">§2.5.1</a>), операции сравнения (<a href="/doc/2.5.2.html">§2.5.2</a>),
булевские (<a href="/doc/2.5.3.html">§2.5.3</a>) и операции конкатенации (смотерть <a
href="/doc/2.5.4.html">§2.5.4</a>). Унарными являются унарный минус (<a href="/doc/2.5.1.html">§2.5.1</a>),
отрицание <b class="contbold">not</b> (<a
href="/doc/2.5.3.html">§2.5.3</a>) и операция получения длины <b class="contbold">#</b> (<a href="/doc/2.5.5.html">§2.5.5</a>). </p>

<p class="contpara">Результат вызова функций и неявные параметры могут содержать несколько
значений. Если при этом они используются в качестве оператора (<a href="/doc/2.4.6.html">§2.4.6</a>)
(только для функций), то все
возвращеннаемые значения отбрасываются. Если это последний (или единственный) элемент
в списке выражений, то никакая корректировка не проводится (если вызов не взят
в скобки). В остальных случаях Lua приводит возвращаемый список к одному элементу, отбрасывая
все значения кроме первого.</p>

<p class="contpara">Далее несколько примеров: </p>

<div class="contdiv"><pre><code class="lua">
	f()                -- результат функции отбрасывается

    g(f(), x)          -- берется первое значение из списка - результата вызова f()

    g(x, f())          -- g получает x и все значения, полученные из f()

    a,b,c = f(), x     -- берется первый элемент результата вызова f()(и c получает nil)

    a,b = ...          -- a получает первый параметр из ..., b - второй (причем а и b могут получить nil, если в качестве неявных параметров ничего не передано)

    a,b,c = x, f()     -- 2 результата из f()

    a,b,c = f()        -- 3 результата из f()

    return f()         -- возвращает все значения из f()

    return ...         -- возвращает все полученные неявные аргументы

    return x,y,f()     -- вернет a, b и все, что вернет f()

    {f()}              -- создаст список со всем результатами вызова f()

    {...}              -- создаст список со всеми неявными параметрами

    {f(), nil}         -- 1 результат из f()
</code></pre></div>

<p>Выражение,<span class="S0"> </span>заключенное<span class="S0"> </span>в<span class="S0"> </span>скобки<span class="S0"> </span>всегда<span class="S0"> </span>возвращает<span class="S0"> </span>только<span class="S0"> </span>одно<span class="S0"> </span>значение.<span class="S0"> </span>Таким<span class="S0"> </span>образом,<span class="S0"> </span><span class="S10">(</span>f<span class="S10">(</span>x<span class="S10">,</span>y<span class="S10">,</span>z<span class="S10">))</span><span class="S0"> </span>всегда<span class="S0"> </span>даст<span class="S0"> </span>единственное<span class="S0"> </span>значение,<span class="S0"> </span>даже<span class="S0"> </span>если<span class="S0"> </span>f<span class="S0"> </span>возвращает<span class="S0"> </span>несколько.<span class="S0"> </span>(Значение<span class="S0"> </span><span class="S10">(</span>f<span class="S10">(</span>x<span class="S10">,</span>y<span class="S10">,</span>z<span class="S10">))</span><span class="S0"> </span>это<span class="S0"> </span>первое<span class="S0"> </span>значение,<span class="S0"> </span>полученное<span class="S0"> </span>из<span class="S0"> </span>f,<span class="S0"> </span>или<span class="S0"> </span><span class="S5">nil</span>,<span class="S0"> </span>если<span class="S0"> </span>f<span class="S0"> </span>не<span class="S0"> </span>возвращает<span class="S0"> </span>значений.)<br /></p>


<h3>2.5.1 – Арифметические операции</h3>

<p class="contpara">Lua поддерживает обычные арифметические операции: двоичные <span
 class="S10">+</span> (сложение), <span
 class="S10">-</span> (вычитание), <span
 class="S10">*</span> (умножение), <span
 class="S10">/</span> (деление), <span
 class="S10">%</span> (остаток от деления), и <span
 class="S10">^</span> (возведение в степень); а также
унарный минус <span  class="S10">-</span> (изменение
знака числа). Если операнды являются числами или строками (которые могут быть преобразованы
в числа <a href="/doc/2.2.1.html">§2.2.1</a>), то операции выполняются обычным образом .
Возведение в степень работает для любого показателя степени. Например, x<span
 class="S10">^</span>(-0.5) подсчитывает величину, обратную квадратному
корню из x.</p>


<h3>2.5.2 – Операции сравнения</h3>

<p class="contpara">Операции сравнения в Lua:</p>

<div class="contdiv"><pre><code class="lua">
	==    ~=    <     >     <=    >=
</code></pre></div>

<p class="contpara">Эти операции всегда возвращают <b class="contbold">false</b> 
или <b class="contbold">true</b>.</p>

<p class="contpara">Сравнение на равенство (<span class="S10">==</span>)
сначала сравнивает типы операндов. Если типы различны, то результатом будет <b class="contbold">false</b>. Иначе сравниваются
значения операндов. Числа и строки сравниваются обычным способом. Объекты (таблицы,
пользовательские данные, потоки и функции) сравниваются по ссылке: два объекта
считаются равными, только если они являются одним и тем же объектом. Создаваемый
объект (таблица, пользовательские данные, поток или функция) не может быть
равен ни одному из уже существующих.</p>

<p class="contpara">Правила преобразования из <a href="/doc/2.2.1.html">§2.2.1</a> <em>НЕ</em> работают в
сравнениях на равенство. Например, <span class="S6">"0"</span><span class="S10">==</span><span class="S4">0</span>
вернет <b class="contbold"><span class="S5">false</span></b>, а t<span class="S10">[</span><span class="S4">0</span><span class="S10">]</span><span class="S0"> </span>и t<span class="S10">[</span><span class="S6">"0"</span><span class="S10">]</span>&nbsp;обозначают различные
записи в таблице.</p>

<p class="contpara">Оператор <span  class="S10">~=</span> прямо
противоположен оператору равенства (<span  class="S10">==</span>).</p>

<p class="contpara">Операторы сравнения на больше-меньше работают следующим образом. Если оба
параметра - числа, то они сравниваются как обычно. Если оба параметра строки,
то их значения сравниваются в соответствии с лексикографическим порядком. Во
всех остальных ситуациях будет вызван метаметод (в данном руководстве не рассматривается). </p>


<h3>2.5.3 – Логические операции</h3>

<p class="contpara">В Lua это операции <b class="contbold">and (и)</b>, <b class="contbold">or (или)</b>, и <b class="contbold">not (не)</b>. Так же, как и в
управляющих конструкциях (<a href="/doc/2.4.4.html">§2.4.4</a>), все логические операции
рассматривают <b class="contbold">false</b> и <b class="contbold">nil</b> как ложь, а все остальное как истину. </p>

<p class="contpara">Операция отрицания <b class="contbold">not</b> всегда возвращает <b class="contbold">false</b> или <b class="contbold"> true</b>. Операция конъюнкции <b class="contbold"> and</b><span lang=EN-US> возвращает
свой первый параметр, если его значение <b class="contbold"> false</b> или <b class="contbold"> nil</b>; в противном случае <b class="contbold"> and</b> возвращает
второй параметр. Оператор дизъюнкции <b class="contbold"> or</b> возвращает первый параметр, если его
значение отлично от <b class="contbold"> nil</b> и <b class="contbold">false</b>;
в противном случае <b class="contbold"> or</b> возвращает второй параметр. Оба оператора вычисляют второй
операнд только в случае нееобходимости.</p>

<p class="contpara">Примеры: </p>

<div class="contdiv"><pre><code class="lua">
    10 or 20            --> 10

    10 or error()       --> 10

    nil or "a"          --> "a"

    nil and 10          --> nil

    false and error()   --> false

    false and nil       --> false

    false or nil        --> nil

    10 and 20           --> 20
</code></pre></div>

<p class="contpara">(В данном руководстве, --&gt; указывает на результат выражения.) </p>


<h3>2.5.4 - Конкатенация</h3>

<p class="contpara">Оператор конкатенации (соединения) строк в Lua обозначается двумя точками ('..'). 
Если оба операнда являются строками или числами, то они будут преобразованы в строки согласно правилам <a href="/doc/2.2.1.html">§2.2.1</a>. 
Иначе будет вызван метаметод (в данном руководстве не рассматривается). </p>


<h3>2.5.5 – Получение длины</h3>

<p class="contpara">Операция получения длины обозначается унарным <b class="contbold">#</b>. В результате
применения операции к строке возвращается количество байт (в обычном понимании
это длина строки, в которой каждый символ занимает 1 байт). </p>

<p class="contpara">Длиной<span class="S0"> </span>таблицы<span class="S0"> </span>t<span class="S0"> </span>
считается<span class="S0"> </span>любой<span class="S0"> </span>целый<span class="S0"> </span>
индекс<span class="S0"> </span>n<span class="S0"> </span>такой,<span class="S0"> </span>
что<span class="S0"> </span>t<span class="S10">[</span>n<span class="S10">]</span><span class="S0"> </span>
не<span class="S0"> </span>равен<span class="S0"> </span><span class="S5">nil</span>,<span class="S0"> </span>
а<span class="S0"> </span>t<span class="S10">[</span>n<span class="S10">+</span><span class="S4">1</span><span class="S10">]</span>
<span class="S0"> </span>равно<span class="S0"> </span><span class="S5">nil</span>.<span class="S0"> </span>Кроме
<span class="S0"> </span>того,<span class="S0"> </span>если<span class="S0"> </span>t<span class="S10">[</span>
<span class="S4">1</span><span class="S10">]</span><span class="S0"> </span>равен<span class="S0"> </span>
<span class="S5">nil</span>,<span class="S0"> </span>то<span class="S0"> </span>
<span class="S10">#</span>t<span class="S0"> </span><span class="S10">=</span><span class="S0"> </span>
<span class="S4">0</span>.<span class="S0"> </span>Для<span class="S0"> </span>регулярных<span class="S0"> </span>
массивов<span class="S0"> </span>от<span class="S0"> </span><span class="S4">1</span><span class="S0"> </span>
до<span class="S0"> </span>n,<span class="S0"> </span>не<span class="S0"> </span>содержащих<span class="S0"> </span>значений
<span class="S0"> </span><span class="S5">nil</span>,<span class="S0"> &nbsp;</span>длиной<span class="S0"> </span>
является<span class="S0"> </span>n,<span class="S0"> </span>то<span class="S0"> </span>есть<span class="S0"> </span>
индекс<span class="S0"> </span>последнего<span class="S0"> </span>значения.<span class="S0"> </span>
Если<span class="S0"> </span>в<span class="S0"> </span>массиве<span class="S0"> </span>присутствуют
<span class="S0"> </span><b class="contbold">"дыры"</b><span class="S0"> </span>(т.е.,<span class="S0"> </span>
значения<span class="S0"> </span><span class="S5">nil</span><span class="S0"> </span>между<span class="S0"> </span>
ненулевыми<span class="S0"> </span>значениями),<span class="S0"> </span>то<span class="S0"> </span>
значением<span class="S0"> </span><span class="S10">#</span>t<span class="S0"> </span>
является<span class="S0"> </span>индекс<span class="S0"> </span>элемента,<span class="S0"> </span>
непосредственно<span class="S0"> </span>предшествующего<span class="S0"> </span>
элементу<span class="S0"> </span><span class="S5">nil</span><span class="S0"> </span>
(поэтому<span class="S0"> </span>любое<span class="S0"> </span>значение<span class="S0"> </span><span class="S5">nil</span>
<span class="S0"> </span>по<span class="S0"> </span>сути<span class="S0"> </span>означает<span class="S0"> </span>конец<span class="S0"> </span>массива).</p>


<h3>2.5.6 – Приоритет операций</h3>

<p class="contpara">Приоритет операций Lua показан на таблице ниже. Самым высоким приоритетом обладает
операция возведения в степень, далее по убыванию: </p>

<div class="contdiv"><pre><code class="lua">
    or
    and
    <     >     <=    >=    ~=    ==
    ..
    +     -
    *     /     %
    not   #     - (unary)
    ^
</code></pre></div>

<p class="contpara">Как обычно, для изменения порядка вычисления выражений вы можете использовать
скобки. Конкатенация ('..') и
возведение в степень ('^') - правоассоциативные операторы. Все остальные
бинарные операторы левоассоциативные. </p>


<h3>2.5.7 – Конструкторы таблиц</h3>

<p class="contpara">Конструкторы таблиц тоже относятся к выражениям. Обработка любого
встречающегося в коде конструктора ведет к созданию новой таблицы. С помощью
конструкторов можно создать как пустые,
так и частично либо полностью заполненные таблицы. Полное описание синтаксиса
конструкторов: </p>

<div class="contdiv"><pre><code class="lua">
    tableconstructor::= '{' [fieldlist] '}'

    fieldlist::= field {fieldsep field} [fieldsep]

    field::= '[' exp ']' '=' exp | Name '=' exp | exp

    fieldsep::= ',' | ';'
</code></pre></div>

<p class="contpara">Каждое<span class="S0"> </span>поле<span class="S0"> </span>вида<span class="S0"> </span>
<span class="S10">[</span>exp1<span class="S10">]</span><span class="S0"> </span><span class="S10">=</span>
<span class="S0"> </span>exp2<span class="S0"> </span>добавляет<span class="S0"> </span>в<span class="S0"> </span>новую
<span class="S0"> </span>таблицу<span class="S0"> </span>значение<span class="S0"> </span>exp2<span class="S0"> </span>
с<span class="S0"> </span>ключом<span class="S0"> </span>exp1.<span class="S0"> </span>Поле<span class="S0"> </span>
вида<span class="S0"> </span>name<span class="S0"> </span><span class="S10">=</span><span class="S0"> </span>
<span class="S14">exp</span><span class="S0"> </span>эквивалентно<span class="S0"> </span>
<span class="S10">[</span><span class="S6">"name"</span><span class="S10">]</span><span class="S0"> </span>
<span class="S10">=</span><span class="S0"> </span>exp.<span class="S0"> </span>Поле<span class="S0"> </span>вида
<span class="S0"> </span><span class="S14">exp</span><span class="S0"> </span>эквивалентно<span class="S0"> </span>
<span class="S10">[</span>i<span class="S10">]</span><span class="S0"> </span><span class="S10">=</span>
<span class="S0"> </span><span class="S14">exp</span>,<span class="S0"> </span>где
<span class="S0"> </span>i<span class="S0"> </span>–<span class="S0"> </span>целочисленный<span class="S0"> </span>
автоинкрементный<span class="S0"> </span>счетчик,<span class="S0"> </span>начинающийся<span class="S0"> </span>
с<span class="S0"> </span><span class="S4">1</span>. Поля
в других форматах не оказывают влияния на этот счетчик. Например, </p>

<div class="contdiv"><pre><code class="lua">
	a = { [f(1)] = g; "x", "y"; x = 1, f(x), [30] = 23; 45 }
</code></pre></div>

<p class="contpara">эквивалентно </p>

<div class="contdiv"><pre><code class="lua">
    do
		local t = {}

		t[f(1)] = g

		t[1] = "x"         

		t[2] = "y"         

		t.x = 1            

		t[3] = f(x)        

		t[30] = 23

		t[4] = 45          

		a = t

    end
</code></pre></div>

<p class="contpara">Если последнее поле в списке задано в форме exp, и exp 
– это вызов функции или неопределенный
список параметров, то все значения, возвращаемые этим выражением,
последовательно включаются в этот список (<a href="/doc/2.5.8.html">§2.5.8</a>). Чтобы этого
избежать, необходимо заключить вызов функции (или список неопределенных
параметров) в скобки (<a href="/doc/2.5.html">§2.5</a>). </p>

<p class="contpara">Список полей может оканчиваться разделителем, что улучшает читабельность
машинно-генерируемого кода.</p>


<h3>2.5.8 – Вызовы функций</h3>

<p class="contpara">Вызовы функций в Lua имеют следующий синтаксис: </p>

<div class="contdiv"><pre><code class="lua">
	functioncall ::= prefixexp args
</code></pre></div>

<p class="contpara">В вызове функции сначала вычисляются префиксное выражение и аргументы. Если
значение префиксного выражения имеет тип <em>function</em>, то эта функция будет вызвана с указанными
аргументами. В противном случае вызывается метаметод (в данном руководстве не рассматривается). </p>

<p class="contpara">Форма записи</p>

<div class="contdiv"><pre><code class="lua">
	functioncall ::= prefixexp ':' Name args
</code></pre></div>

<p class="contpara">может использоваться для вызова &quot;методов&quot;. Запись<span class="S0"> </span>v:name
<span class="S10">(</span>args<span class="S10">)</span><span class="S0"> </span>синтаксически<span class="S0"> </span>
аналогична<span class="S0"> </span>записи<span class="S0"> </span>v.name<span class="S10">
(</span>v<span class="S10">,</span>args<span class="S10">)</span>,<span class="S0"> </span>
только<span class="S0"> </span>v<span class="S0"> </span>вычисляется<span class="S0"> </span>
один<span class="S0"> </span>раз. </p>

<p class="contpara">Аргументы описываются следующим образом: </p>

<div class="contdiv"><pre><code class="lua">
	args ::= '(' [explist1] ')'

    args ::= tableconstructor

    args ::= String
</code></pre></div>

<p class="contpara">Все выражения вычисляются перед вызовом. Вызов<span class="S0"> </span>в<span class="S0"> 
</span>форме<span class="S0"> </span>f<span class="S10">{</span>fields<span class="S10">}</span><span class="S0"> 
</span>синтаксически<span class="S0"> </span>аналогичен<span class="S0"> </span>f<span class="S10">
({</span>fields<span class="S10">})</span>;<span class="S0"> </span>то<span class="S0"> </span>
есть<span class="S0"> </span>список<span class="S0"> </span>аргументов<span class="S0"> &nbsp;</span>
является<span class="S0"> </span>по<span class="S0"> </span>сути<span class="S0"> </span>новой<span class="S0"> 
</span>таблицей.<span class="S0"> </span>Вызов<span class="S0"> </span>в<span class="S0"> </span>
форме<span class="S0"> </span>f<span class="S7">'string'</span><span class="S0"> </span>
(или<span class="S0"> </span>f<span class="S6">"string"</span><span class="S0"> </span>
или<span class="S0"> </span>f<span class="S8">[[string]]</span>)<span class="S0"> </span>синтаксически
<span class="S0"> </span>равен<span class="S0"> </span>f<span class="S10">(</span><span class="S7">'string'</span>
<span class="S10">)</span>; в данном случае список аргументов -
единстванная символьная строка. </p>

<p class="contpara">Исключением в довольно свободном синтаксисе Lua является правило, по которому нельзя
переходить на новую строку непосредственно перед символом '(' в вызове функции. Это ограничение позволяет
избежать некоторой двусмысленности в языке. Если вы напишите </p>

<div class="contdiv"><pre><code class="lua">
	a = f

    (g).x(a)
</code></pre></div>

<p class="contpara">Lua<span class="S0"> </span>трактует<span class="S0"> </span>эту<span class="S0"> 
</span>запись<span class="S0"> </span>как<span class="S0"> </span>выражение<span class="S0"> 
</span>a<span class="S0"> </span><span class="S10">=</span><span class="S0"> </span>f<span class="S10">
(</span>g<span class="S10">).</span>x<span class="S10">(</span>a<span class="S10">)</span>. 
Поэтому, если вам нужно 2 выражения, вы должны добавить точку с запятой между ними. Если вы действительно хотите
вызвать f, вы необходимо убрать переход на новую строку перед (g). </p>

<p class="contpara">Вызов в форме return<em> functioncall</em> называется
<em>концевым вызовом</em>. Lua также поддерживает <em>концевой вызов «себя» </em> (или <i class="contitalic">рекурсивный</i>
<em>концевой вызов</em>): в этом случае вызванная функция использует стек
вызывающей функции. Поэтому количество вложенных концовых вызовов может быть
любым. Заметим только, что концевой вызов стирает отладочную информацию о
вызывающей функции. Синтаксис концевого вызова допускает только единичный вызов
функции после оператора <b class="contbold">return</b>.
Таким образом, <b class="contbold">return</b> вернет в точности тот
результат, что вернет вызов функции. Ни один из представленных ниже примеров не
является допустимым концевым вызовом: </p>

<div class="contdiv"><pre><code class="lua">
    return (f(x))        -- список-результат обрезается

    return 2 * f(x)      -- удвоение результата функции

    return x, f(x)       -- возвращается несколько значений

    f(x); return         -- результат вызова отбрасывается

    return x or f(x)     -- список-результат обрезается
</code></pre></div>


<h3></a>2.5.9 – Объявление функций</h3>

<p class="contpara">Синтаксис объявления функций: </p>

<div class="contdiv"><pre><code class="lua">
    function ::= function funcbody

    funcbody ::= '(' [parlist1] ')' block end
</code></pre></div>

<p class="contpara">Или в упрощенном виде</p>

<div class="contdiv"><pre><code class="lua">
    stat ::= function funcname funcbody

    stat ::= local function Name funcbody

    funcname ::= Name {'.' Name} [':' Name]
</code></pre></div>

<p class="contpara">Выражение</p>

<div class="contdiv"><pre><code class="lua">
	function f () body end
</code></pre></div>

<p class="contpara">транслируется в</p>

<div class="contdiv"><pre><code class="lua">
	f = function () body end
</code></pre></div>

<p class="contpara">Выражение</p>

<div class="contdiv"><pre><code class="lua">
	function t.a.b.c.f () body end
</code></pre></div>

<p class="contpara">транслируется в</p>

<div class="contdiv"><pre><code class="lua">
	t.a.b.c.f = function () body end
</code></pre></div>

<p class="contpara">Выражение</p>

<div class="contdiv"><pre><code class="lua">
	local function f () body end
</code></pre></div>

<p class="contpara">транслируется в</p>

<div class="contdiv"><pre><code class="lua">
	local f; f = function () body end
</code></pre></div>

<p class="contpara"><em>а</em><em> не</em><em> в</em></p>

<div class="contdiv"><pre><code class="lua">
	local f = function () body end
</code></pre></div>

<p class="contpara">(Разница проявится в том случае, если в теле функции используется имя этой функции,
например при рекурсивном вызове) </p>

<p class="contpara">Объявление функции является выполняемым выражением, его результатом будет
значение типа <em>function</em>. Когда Lua прекомпилирует
порцию, тела всех упоминающихся в ней функций также прекомпилируются. Таким
образом, всякий раз, когда Lua обрабатывает объявление функции, функция уже <i class="contitalic">конкретизирована</i> 
(или <i class="contitalic">замкнута</i>). Этот конкретный экземпляр функции
(или замыкание) и является конечным значением выражения «объявление функции». Различные
экземпляры одной и той же функции могу ссылаться на различные внешние локальные
переменные и иметь различные таблицы окружения. </p>

<p class="contpara">Параметры функции фактически являются локальными переменными, которые
инициализированы входными значениями: </p>

<div class="contdiv"><pre><code class="lua">
	parlist1 ::= namelist [',' '...'] | '...'
</code></pre></div>

<p class="contpara">В момент вызова функции длина списка передаваемых параметров приводится в
соответствие спецификации, если это не <em>функция</em> с неопределенным
количеством параметров. Для функций с неопределенным количеством параметров
такая коррекция не проводится; все входные параметры попадают в функцию в виде 
<i class="contitalic">неопределенного выражения</i>, которое также обозначается с тремя точками. 
Значением этого выражения является список всех полученных входных параметров, как в случае 
множественного результата функции. Еслы <i class="contitalic">неопределенное</i> 
<i class="contitalic">выражение</i> используется внутри другого выражения или в середине
списка выражений, то его значение-список урезается до одного элемента. Если это
выражение стоит в конце списка выражений, урезания не происходит (если конечно
вызов не заключен в круглые скобки). </p>

<p class="contpara">Рассмотрим следующие объявления: </p>

<div class="contdiv"><pre><code class="lua">
    function f(a, b) end

    function g(a, b, ...) end

    function r() return 1,2,3 end
</code></pre></div>

<p class="contpara">Пример отображения входных значений на параметры функции: </p>

<div class="contdiv"><pre><code class="lua">
	ВЫЗОВ			ПАРАМЕТРЫ           

    f(3)             a=3, b=nil

    f(3, 4)          a=3, b=4

    f(3, 4, 5)       a=3, b=4

    f(r(), 10)       a=1, b=10

    f(r())           a=1, b=2


    g(3)             a=3, b=nil, ... -->  (ничто)

    g(3, 4)          a=3, b=4,   ... -->  (ничто)

    g(3, 4, 5, 8)    a=3, b=4,   ... -->  5  8

    g(5, r())        a=5, b=1,   ... -->  2  3
</code></pre></div>

<p class="contpara">Результаты возвращаются из функции оператором <b class="contbold">return</b> (см. <a href="/doc/2.4.4.html">§2.4.4</a>).
. Если управление достигает конца функции, а оператор <b class="contbold">return </b>не встретился, то функция завершается
и ничего не возвращает.</p>

<p class="contpara"><em>Синтаксис с двоеточием <b class="contbold">‘:’</b></em> используется для определения <em>методов. </em><em>Эти
фун</em>кций неявно получают параметр self в качестве первого аргумента. Таким образом, выражение </p>

<div class="contdiv"><pre><code class="lua">
	function t.a.b.c:f (params) body end
</code></pre></div>

<p class="contpara">аналогично </p>

<div class="contdiv"><pre><code class="lua">
	t.a.b.c.f = function (self, params) body end
</code></pre></div>



<h2>2.6 – Области видимости</h2>

<p class="contpara">Lua язык с лексическим разграничением областей видимости. Область видимости переменной
начинается первым выражением <i class="contitalic">после</i> ее
объявления и действует до конца блока, в котором это объявление встречается. Рассмотрим
следующий пример: </p>

<div class="contdiv"><pre><code class="lua">
    x = 10                	-- глобальная переменная variable

    do                    	-- начало блока
		local x = x         -- объявление локальной переменной

		print(x)            --> 10

		x = x+1

		do                  -- начало вложенного блока
			local x = x+1   -- другая локальная 'x'

			print(x)        --> 12
		end

		print(x)            --> 11
    end

    print(x)              	--> 10  (глобальная переменная)
</code></pre></div>

<p class="contpara">Отметим, что в объявлении local x = x локальная переменная объявляется еще не
в области своей видимости, поэтому присваивается именно внешняя переменная. </p>

<p class="contpara">В соответствии с правилами лексического разграничения областей видимости, локальные
переменные доступны в функциях, определенных внутри их области видимости. Локальная
переменная, используемая в таких функциях, называется <i class="contitalic">внешней<em> локальной переменной 
</em></i><em>(по отношению к определенной</em> внутри ее области видимости функции). </p>

<p class="contpara">Обработка каждого объявления <b class="contbold">local</b> ведет к созданию новой
локальной переменной. Рассмотрим следующий пример:</p>

<div class="contdiv"><pre><code class="lua">
	a = {}

    local x = 20

    for i=1,10 do

		local y = 0

		a[i] = function () y=y+1; return x+y end

    end
</code></pre></div>

<p class="contpara">Цикл создает 10 экземпляров функции, в которых используются различные переменные 
y и один и тот же x. </p>



<h2>2.7 – Обработка ошибок</h2>

<p class="contpara">Поскольку Lua является языком расширений, работа Lua начинаются с момента
вызова в C-коде базовой программы функции
из Lua-библиотеки (<a href="#lua_pcall">lua_pcall</a>). При
возникновении ошибки в процессе компиляции или выполнения Lua управление возвращается
в C -программу, где и
осуществляется ее обработка (например вывод сообщения о ошибке). </p>

<p class="contpara">Lua-код может явно генерировать ошибку, вызывая функцию <a href="#pdf-error">error</a>.
Если вам нужно перехватывать ошибки в самом Lua, вы можете использовать функцию <a href="#pdf-pcall">pcall</a>.</p>


<h2>2.8 – Сборщик мусора</h2>

<p class="contpara">Lua осуществляет автоматичекое управление памятью. Это означает, что вам не нужно
думать о выделении памяти при создании новых объектов и ее освобождении, когда
объект становится ненужным. Lua время от времени автоматически запускает процедуру <i class="contitalic">сборки мусора 
</i>для удаления <i class="contitalic">устаревших объектов</i> (то есть объектов, которые более недоступны из Lua).
Сборщик мусора обрабатывает все объекты Lua: таблицы, данные типа userdata, функции, потоки и строки. </p>



<h1><a name="fundamentals">3 - Использование Lua в программе GEDKeeper</a></h1>

<h2><a name="specifications">3.1 - Соглашения</a></h2>

<p class="contpara">
Префикс "gk_" - обозначает функции общего назначения<br>
Префикс "gt_" - обозначает функции для работы с деревом<br>
</p>

<p class="contpara">Типы данных:<br>
void - пустой аргумент или результат функции;<br>
int - целочисленный аргумент или результат функции;<br>
string - строковый аргумент или результат функции;<br>
boolean - логический аргумент или результат функции;<br>
</p>

<p class="contpara">
Внимание:
	Все списки базы данных нумеруются от нуля, поэтому для перебора
	всех записей базы данных следует использовать, к примеру,
	такую конструкцию:
</p>

<div class="contdiv"><pre><code class="lua">
for i = 0, gt_get_records_count() - 1 do -- т.е. число элементов "-1"
	...
end
</code></pre></div>

<h2><a name="structs">3.2 - Структуры данных</a></h2>

<p class="contpara">Все действия над структурами данных базе выполняются посредством указателей (pointer) на эти структуры. 
Указатель - специальная переменная, указывающая программе на ту или иную структуру в памяти.</p>

<p class="contpara">
Указатели на структуры имеют следующие типы:
<ul>
<li>pointer (простой указатель)<ul>
	<li>record_pointer (указатель на запись)<ul>
		<li>person_pointer (указатель на запись персоны)</li>
		<li>family_pointer (указатель на запись семьи)</li>
		<li>note_pointer (указатель на запись заметки)</li>
		<li>source_pointer (указатель на запись источника)</li>
		<li>repository_pointer (указатель на запись архив)</li>
		<li>multimedia_pointer (указатель на запись мультимедиа-объекта)</li>
		<li>group_pointer (указатель на запись группы)</li>
		<li>research_pointer (указатель на запись исследования)</li>
		<li>task_pointer (указатель на запись задачи)</li>
		<li>commumication_pointer (указатель на запись коммуникаций)</li>
		<li>location_pointer (указатель на запись места)</li>
		</ul></li>
	</ul></li>
	<li>struct_pointer (указатель на структуру - вложенный объект записи)<ul>
		<li>association_pointer (указатель на ассоциацию)</li>
		<li>event_pointer (указатель на событие/факт)</li>
		</ul></li>
	</ul></li>
</ul>
</p>

<h2><a name="functions">3.3 - Функции (API)</a></h2>

<p class="contpara">
<dl>
	<dt>void gk_print(string text)</dt>
	<dd>вывод строки text;</dd>

	<dt>void gk_progress_init(int length, string title)</dt>
	<dd>показывает окно прогрессии, где length - число этапов прогрессии, title - заголовок;</dd>

	<dt>void gk_progress_done()</dt>
	<dd>скрывает окно прогрессии;</dd>

	<dt>void gk_progress_step()</dt>
	<dd>увеличивает число выполненных этапов прогрессии на один;</dd>

	<dt>int gk_strpos(string substr, string str)</dt>
	<dd>возвращает индекс первого вхождения подстроки substr в строке str;</dd>

	<dt>void gk_update_view()</dt>
	<dd>полностью обновляет вид всех списков (бывает необходимо после массовой обработки данных);</dd>
	
	<dt>string gk_select_file()</dt>
	<dd>открывает диалог выбора файла и возвращает строку с именем файла</dd>


	<dt>int gt_get_records_count()</dt>
	<dd>возвращает число записей в БД;</dd>

	<dt>record_ptr gt_get_record(int index)</dt>
	<dd>возвращает запись базы данных по заданному индексу.
	Внимание: записи различных типов располагаются в БД
	в произвольном порядке - так, как они вводились. Для
	обработки всех записей определенного типа, необходимо
	проверять их тип.</dd>

	<dt>int gt_get_record_type(record_ptr)</dt>
	<dd>возвращает код - числовую константу, определяющую тип записи;
	возможные варианты:<ul>
	<li>rtNone - тип не определяется либо неизвестен</li>
	<li>rtIndividual - персональная запись</li>
	<li>rtFamily - семья</li>
	<li>rtNote - заметка</li>
	<li>rtMultimedia - мультимедийная запись</li>
	<li>rtSource - запись источника</li>
	<li>rtRepository - архив или хранилище источников</li>
	<li>rtGroup - группа</li>
	<li>rtResearch - исследование</li>
	<li>rtTask - задача</li>
	<li>rtCommunication - коммуникации/переписка</li>
	<li>rtLocation - место</li>
	<li>rtSubmission - [зарезервировано (пока не используется)]</li>
	<li>rtSubmitter - исследователь базы данных</li>
	</ul></dd>

	<dt>string gt_get_record_type_name(int type)</dt>
	<dd>возвращает строку с идентификатором типа записи по его коду.</dd>

	<dt>string gt_get_record_xref(record_ptr)</dt>
	<dd>возвращает строку - идентификатор записи, обеспечивающий перекрестные ссылки между записями в базе</dd>

	<dt>string gt_get_record_uid(record_ptr)</dt>
	<dd>возвращает глобальный уникальный идентификатор записи в базе данных</dd>

	<dt>gt_delete_record(record)</dt>
	<dd>удаляет запись из базы данных</dd>

	<dt>boolean gt_record_is_filtered(record_ptr)</dt>
	<dd>возвращает логический признак, что данная запись отфильтрована и содержится в текущей отображаемой выборке</dd>


	<dt>string gt_get_person_name(record)</dt>
	<dd>возвращает полное имя персоны.</dd>


	<dt>int gt_get_person_associations_count(person_ptr)</dt>
	<dd>возвращает количество ассоциаций заданной персоны.</dd>

	<dt>ptr gt_get_person_association(person_ptr, int index)</dt>
	<dd>возвращает ассоциацию заданной персоны по индексу.</dd>

	<dt>gt_delete_person_association(person_ptr, index)</dt>
	<dd>удаляет ассоциацию персоны с заданным индексом.</dd>


	<dt>int gt_get_person_events_count(person_ptr)</dt>
	<dd>возвращает количество фактов персоны.</dd>

	<dt>event_ptr gt_get_person_event(person_ptr, int index)</dt>
	<dd>возвращает заданный индексом факт персоны.</dd>

	<dt>gt_delete_person_event(person_ptr, int index)</dt>
	<dd>удаляет заданный индексом факт персоны.</dd>


	<dt>string gt_get_event_value(event_ptr)</dt>
	<dd>возвращает строковое значение факта персоны.</dd>

	<dt>string gt_get_event_place(event_ptr)</dt>
	<dd>возвращает строку места факта персоны.</dd>

	<dt>string gt_get_event_date(event_ptr)</dt>
	<dd>возвращает строковое значение даты факта</dd>

	<dt>string gt_get_event_name(event_ptr)</dt>
	<dd>возвращает строку с именем-идентификатором типа факта (внимание - это внутренние идентификаторы фактов, см. <a href="">Идентификаторы типа факта</a>)</dd>


	<dt>person_ptr gt_create_person(string name, string patronymic, string family, string sex)</dt>
	<dd>создает новую персональную запись, где name-имя, patronymic-отчество, family-фамилия, sex-пол (варианты значений: "N"-не задан, "M"-мужской, "F"-женский, "U"-неопределенный)</dd>

	<dt>family_ptr gt_create_family()</dt>
	<dd>создает новую запись семьи</dd>

	<dt>gt_bind_family_spouse(family_ptr family, person_ptr spouse)</dt>
	<dd>присоединяет супруга "spouse" к семье "family". Внимание: у записи супруга должен быть задан пол, т.к. по нему автоматически определяется роль в семье.</dd>


	<dt>bool csv_load(string filename, bool first_line_is_schema)</dt>
	<dd>загрузить csv-таблицу, первый параметр определяет имя файла, второй - содержит ли первая строка файла заголовки колонок</dd>

	<dt>csv_close()</dt>
	<dd>закрыть csv-таблицу</dd>

	<dt>int csv_get_cols()</dt>
	<dd>получить количество столбцов в csv-таблице</dd>

	<dt>int csv_get_rows()</dt>
	<dd>получить количество строк в csv-таблице</dd>

	<dt>string csv_get_cell(col, row)</dt>
	<dd>получить содержимое ячейки в csv-таблице (столбцы и строки нумеруются от нуля)</dd>


	<dt>note_ptr gt_create_note()</dt>
	<dd>создать новую запись заметки</dd>

	<dt>gt_bind_record_note(record_ptr, note_ptr)</dt>
	<dd>присоединить к записи заметку</dd>

	<dt>gt_add_note_text(note_ptr, string text)</dt>
	<dd>добавляет в запись заметки текстовую строку</dd>

	<dt>record_ptr gt_select_record(int record_type)</dt>
	<dd>вызывает диалог выбора записи из имеющихся</dd>

	<dt>gt_bind_record_source(record_ptr, source_ptr, string page, int quality)</dt>
	<dd>присоединяет к любой записи заданный источник, устанавливает страницу (page) и качество источника (quality, 0..3)</dd>

	<dt>string gt_define_sex(string name, string patronymic)</dt>
	<dd>возвращает идентификатор пола, определенный по имени и отчеству</dd>

	<dt>gt_set_event_place(event_ptr, string place)</dt>
	<dd>установить факту свойство места</dd>

	<dt>source_record gt_create_source(string name)</dt>
	<dd>создает новый источник с заданным названием</dd>

	<dt>source_record gt_find_source(string name)</dt>
	<dd>ищет в списке источник с требуемым названием</dd>

	<dt>event_ptr gt_create_event(record_ptr, string sign)</dt>
	<dd>создать новый факт в записях персон или семей, где sign - строковый тип факта</dd>

	<dt>gt_set_event_date(event_ptr, string date)</dt>
	<dd>установить факту дату</dd>

	<dt>gt_bind_family_child(family_ptr, person_ptr child)</dt>
	<dd>присоединить к семье ребенка</dd>

	<dt>association_ptr gt_add_person_association(person_ptr, string relation, person_ptr rel_person)</dt>
	<dd>добавяет персоне person_record, ссылку-ассоциацию на персону rel_person.
	Используется, к примеру, когда нужно сделать ссылки на крестных.</dd>

	<dt>string gt_define_patronymic(string father_name, string child_sex, bool confirm)</dt>
	<dd>определяет при помощи встроенного словаря отчество ребенка с полом child_sex по имени отца father_name. 
	Параметр confirm(true|false) определяет - спрашивать ли пользователя в сомнительных случаях.</dd>

	<dt>family_record gt_get_person_parents_family(person_ptr)</dt>
	<dd>возвращает семью родителей данной персоны</dd>

	<dt>int gt_get_person_spouses_count(person_ptr)</dt>
	<dd>возвращает число супругов данной персоны</dd>

	<dt>family_ptr gt_get_person_spouse_family(person_ptr, int index)</dt>
	<dd>возвращает семью данной персоны и его(её) супруги, index - определяет номер брака</dd>

	<dt>person_ptr gt_get_family_husband(family_ptr)</dt>
	<dd>возвращает персону мужа данной семьи</dd>

	<dt>person_ptr gt_get_family_wife(family_ptr)</dt>
	<dd>возвращает персону жены данной семьи</dd>

	<dt>int gt_get_family_childs_count(family_ptr)</dt>
	<dd>возвращает число детей в данной семье</dd>

	<dt>person_ptr gt_get_family_child(family_ptr, int index)</dt>
	<dd>возвращает персону ребенка заданной семьи по его номеру</dd>

	<dt></dt>
	<dd></dd>
	<dt></dt>
	<dd></dd>

	<dt></dt>
	<dd></dd>

	<dt></dt>
	<dd></dd>

	<dt></dt>
	<dd></dd>
	<dt></dt>
	<dd></dd>

	<dt></dt>
	<dd></dd>

	<dt></dt>
	<dd></dd>

	<dt></dt>
	<dd></dd>
	<dt></dt>
	<dd></dd>

	<dt></dt>
	<dd></dd>

	<dt></dt>
	<dd></dd>

	<dt></dt>
	<dd></dd>
</dl>
</p>


</td></tr></table>

</body>

</html>
